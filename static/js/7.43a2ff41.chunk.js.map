{"version":3,"file":"static/js/7.43a2ff41.chunk.js","mappings":"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","sources":["../webpack/bootstrap","../webpack/runtime/get javascript chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","utils/board.ts","utils/game.ts","utils/mcts.ts","utils/player.ts","utils/negamax.ts","utils/nigamax.ts","worker.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"42225515\" + \".chunk.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/POLYTECH-IA-PROJET-PIPOPIPETTE/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t7: 1\n};\n\n// no chunk install function needed\n// no chunk loading\n\n// no HMR\n\n// no HMR manifest","import { Coup } from \"./player\";\r\n\r\nexport type NodeGenerator = Generator<\r\n    {\r\n        x: number;\r\n        y: number;\r\n        board: Board;\r\n        orientation: \"vertical\" | \"horizontal\";\r\n    },\r\n    void,\r\n    void\r\n>;\r\n\r\nexport type PlayValue = -1 | 0 | 1;\r\nexport type PlayerValue = 0 | 1;\r\n\r\nexport class Board {\r\n    readonly cells: ReadonlyArray<ReadonlyArray<PlayValue>> = [];\r\n    readonly verticals: ReadonlyArray<ReadonlyArray<PlayValue>> = [];\r\n    readonly horizontals: ReadonlyArray<ReadonlyArray<PlayValue>> = [];\r\n    readonly previousBoard: Board | null = null;\r\n    readonly score: readonly [number, number] = [0, 0];\r\n    readonly tour: PlayerValue = 0;\r\n\r\n    constructor(size: number);\r\n    constructor(board: { cells: PlayValue[][]; verticals: PlayValue[][]; horizontals: PlayValue[][]; score: [number, number]; tour: PlayerValue, previousBoard?: Board });\r\n    constructor(BoardOrSize: number | { cells: PlayValue[][]; verticals: PlayValue[][]; horizontals: PlayValue[][]; score: [number, number]; tour: PlayerValue, previousBoard?: Board }) {\r\n        if (typeof BoardOrSize === \"number\") {\r\n            this.cells = new Array(BoardOrSize).fill(0).map(() => new Array(BoardOrSize).fill(-1));\r\n            this.verticals = new Array(BoardOrSize)\r\n                .fill(0)\r\n                .map(() => new Array(BoardOrSize + 1).fill(-1));\r\n            this.horizontals = new Array(BoardOrSize + 1)\r\n                .fill(0)\r\n                .map(() => new Array(BoardOrSize).fill(-1));\r\n            this.score = [0, 0];\r\n            this.tour = 0;\r\n        } else {\r\n            this.cells = BoardOrSize.cells;\r\n            this.verticals = BoardOrSize.verticals;\r\n            this.horizontals = BoardOrSize.horizontals;\r\n            this.score = BoardOrSize.score;\r\n            this.tour = BoardOrSize.tour;\r\n            this.previousBoard = BoardOrSize.previousBoard || null;\r\n        }\r\n    }\r\n\r\n    public getCells(): ReadonlyArray<ReadonlyArray<PlayValue>> {\r\n        return this.cells;\r\n    }\r\n\r\n    public getVerticals(): ReadonlyArray<ReadonlyArray<PlayValue>> {\r\n        return this.verticals;\r\n    }\r\n\r\n    public getHorizontals(): ReadonlyArray<ReadonlyArray<PlayValue>> {\r\n        return this.horizontals;\r\n    }\r\n\r\n    public getScore(): readonly [number, number] {\r\n        return this.score;\r\n    }\r\n\r\n    public getWinner(): 0 | 1 | null {\r\n        if (this.score[0] > this.cells.length ** 2 / 2) return 0;\r\n        if (this.score[1] > this.cells.length ** 2 / 2) return 1;\r\n        return null;\r\n    }\r\n\r\n    public getTour(): PlayerValue {\r\n        return this.tour;\r\n    }\r\n\r\n    public play(\r\n        orientation: \"vertical\" | \"horizontal\",\r\n        x: number,\r\n        y: number\r\n    ): Board | null {\r\n\r\n        const newHorizontals = this.horizontals.map((row) => [...row]);\r\n        const newVerticals = this.verticals.map((row) => [...row]);\r\n        const newCells = this.cells.map((row) => [...row]);\r\n        const newScore = [...this.score];\r\n        let newTour = this.tour;\r\n\r\n        if (orientation === \"vertical\") {\r\n            if (newVerticals[y][x] !== -1) throw new Error(\"Invalid move\");\r\n            newVerticals[y][x] = this.tour;\r\n        } else {\r\n            if (newHorizontals[y][x] !== -1) throw new Error(\"Invalid move\");\r\n            newHorizontals[y][x] = this.tour;\r\n\r\n\r\n        }\r\n\r\n        const cells: Array<[x: number, y: number]> = [];\r\n\r\n        if (orientation === \"horizontal\") {\r\n            let result = this.check(newHorizontals, newVerticals, x, y);\r\n            if (result) cells.push(result);\r\n            result = this.check(newHorizontals, newVerticals, x, y - 1);\r\n            if (result) cells.push(result);\r\n        } else {\r\n            let result = this.check(newHorizontals, newVerticals, x, y);\r\n            if (result) cells.push(result);\r\n            result = this.check(newHorizontals, newVerticals, x - 1, y);\r\n            if (result) cells.push(result);\r\n        }\r\n\r\n        if (!cells.length) {\r\n            newTour = newTour === 1 ? 0 : 1;\r\n        } else {\r\n            newScore[newTour] += cells.length;\r\n\r\n            cells.forEach((cell) => {\r\n                newCells[cell[1]][cell[0]] = newTour;\r\n            });\r\n        }\r\n\r\n        return new Board({\r\n            cells: newCells,\r\n            verticals: newVerticals,\r\n            horizontals: newHorizontals,\r\n            score: newScore as [number, number],\r\n            tour: newTour,\r\n            previousBoard: this\r\n        });\r\n    }\r\n\r\n    public isFinished() {\r\n        return this.score[0] > this.cells.length ** 2 / 2 || this.score[1] > this.cells.length ** 2 / 2 || this.score[0] + this.score[1] === this.cells.length ** 2;\r\n    }\r\n\r\n    private check(horizontals: PlayValue[][], verticals: PlayValue[][], x: number, y: number): false | [x: number, y: number] {\r\n        if (x < 0 || x >= this.cells.length || y < 0 || y >= this.cells.length) {\r\n            return false;\r\n        }\r\n        if (\r\n            verticals[y][x] !== -1 &&\r\n            verticals[y][x + 1] !== -1 &&\r\n            horizontals[y][x] !== -1 &&\r\n            horizontals[y + 1]?.[x] !== -1\r\n        ) {\r\n            return [x, y];\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public evaluation(idPlayer: PlayerValue) {\r\n        return this.score[idPlayer] - this.score[idPlayer === 1 ? 0 : 1];\r\n    }\r\n\r\n\r\n    public *getNodes(): NodeGenerator {\r\n        const playable = [\r\n            ...this.verticals\r\n                .flatMap((row, y) => row.map((value, x) => ({ x, y, value, orientation: \"vertical\" } satisfies Coup & { value: number })))\r\n                .filter(({ value }) => value === -1),\r\n            ...this.horizontals\r\n                .flatMap((row, y) => row.map((value, x) => ({ x, y, value, orientation: \"horizontal\" } satisfies Coup & { value: number })))\r\n                .filter(({ value }) => value === -1)\r\n        ]\r\n\r\n        while (playable.length > 0) {\r\n            const { x, y, orientation } = playable.splice(\r\n                Math.floor(Math.random() * playable.length),\r\n                1\r\n            )[0];\r\n            const board = this.play(orientation, x, y)!;\r\n            if (board.tour === board.previousBoard!.tour && !board.isFinished()) {\r\n                for (const node of board.getNodes()) {\r\n                    yield { ...node, x, y, orientation };\r\n                }\r\n            } else yield { x, y, board, orientation };\r\n        }\r\n    }\r\n}\r\n\r\n\r\n","import { Board } from \"./board\";\r\nimport { Player } from \"./player\";\r\nexport default class Game extends EventTarget {\r\n  private board: Board;\r\n  private players: [Player, Player];\r\n\r\n  constructor(size: number, player1: Player, player2: Player) {\r\n    super();\r\n    this.board = new Board(size);\r\n    this.players = [player1, player2];\r\n    this.play();\r\n  }\r\n\r\n  getBoard() {\r\n    return this.board;\r\n  }\r\n\r\n  private async play() {\r\n    while (!this.board.isFinished()) {\r\n      await this.players[this.board.getTour()].play(this.board, this.board.getTour()).then((coup) => {\r\n        const newBoard = this.board.play(coup.orientation, coup.x, coup.y)\r\n        if (newBoard) {\r\n          this.board = newBoard;\r\n          this.dispatchEvent(new CustomEvent(\"played\", {\r\n            detail: {\r\n              played: {\r\n                x: coup.x, y: coup.y, orientation: coup.orientation, player: newBoard.previousBoard!.tour\r\n              },\r\n              board: {\r\n                verticals: this.board.getVerticals(),\r\n                horizontals: this.board.getHorizontals(),\r\n                cells: this.board.getCells(),\r\n                score: this.board.getScore(),\r\n                player: this.board.getTour()\r\n              }\r\n            }\r\n          }));\r\n        }\r\n      });\r\n    }\r\n    const [player1, player2] = this.board.getScore();\r\n\r\n    this.dispatchEvent(new CustomEvent(\"end\", {\r\n      detail: {\r\n        winner: player1 > player2 ? 0 : player1 < player2 ? 1 : -1\r\n      }\r\n    }));\r\n  }\r\n\r\n  public async start() {\r\n    await this.play();\r\n  }\r\n}\r\n","import { Board } from \"./board\";\r\n\r\nexport class MctsNode {\r\n    public wins: number;\r\n    public visits: number;\r\n    public nodes: Map<\"vertical\" | \"horizontal\", Map<number, Map<number, MctsNode>>>;\r\n    public parent: MctsNode | null;\r\n    private board: Board;\r\n    private player: 0 | 1;\r\n    private simulation: number;\r\n    private c: number\r\n    private generator: Generator<{ orientation: \"vertical\" | \"horizontal\"; x: number; y: number, board: Board }, void, unknown>;\r\n\r\n    constructor(board: Board, player: 0 | 1, simulation: number, c: number, parent: MctsNode | null = null) {\r\n        this.wins = 0;\r\n        this.visits = 0;\r\n        this.nodes = new Map();\r\n        this.parent = parent;\r\n        this.generator = board.getNodes();\r\n        this.board = board;\r\n        this.simulation = simulation;\r\n        this.player = player;\r\n        this.c = c;\r\n    }\r\n\r\n\r\n    public run() {\r\n        if (this.board.isFinished()) {\r\n            for (let i = 0; i < this.simulation; i++) {\r\n                this.backpropagation(this.simulate());\r\n            }\r\n            return\r\n        }\r\n\r\n        let newChild = this.expansion()\r\n\r\n        if (newChild) {\r\n            for (let i = 0; i < this.simulation; i++) {\r\n                newChild.backpropagation(newChild.simulate());\r\n            }\r\n        }\r\n        else {\r\n            const { bestNode } = this.selection();\r\n            bestNode.run();\r\n        }\r\n    }\r\n\r\n    private selection(): {\r\n        bestNode: MctsNode;\r\n        x: number;\r\n        y: number;\r\n        orientation: \"vertical\" | \"horizontal\";\r\n    } {\r\n        let bestNode: MctsNode | null = null;\r\n        let x: number = 0;\r\n        let y: number = 0;\r\n        let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n        let bestValue = -Infinity;\r\n        this.nodes.forEach((row, _orientation) => {\r\n            row.forEach((cell, _x) => {\r\n                cell.forEach((node, _y) => {\r\n                    const value = node.wins / node.visits + this.c * Math.sqrt(2 * Math.log(this.visits) / node.visits);\r\n                    if (value > bestValue) {\r\n                        bestValue = value;\r\n                        orientation = _orientation as \"vertical\" | \"horizontal\";\r\n                        x = +_x;\r\n                        y = +_y;\r\n                        bestNode = node;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return { bestNode: bestNode!, x, y, orientation };\r\n    }\r\n\r\n    private simulate() {\r\n        let gen = this.board.getNodes();\r\n        let result: Board = this.board\r\n        for (let node of gen) {\r\n            result = result.play(node.orientation, node.x, node.y)!;\r\n        }\r\n        return result.getWinner() === this.player;\r\n    }\r\n\r\n    private expansion() {\r\n        const { value, done } = this.generator.next();\r\n\r\n        if (done) return false;\r\n\r\n        const { orientation, x, y, board } = value;\r\n        const child = new MctsNode(board, this.player, this.simulation, this.c, this);\r\n        let mapOrientation = this.nodes.get(orientation);\r\n        if (!mapOrientation) {\r\n            mapOrientation = new Map();\r\n            this.nodes.set(orientation, mapOrientation);\r\n        }\r\n\r\n        let mapX = mapOrientation.get(x);\r\n        if (!mapX) {\r\n            mapX = new Map();\r\n            mapOrientation.set(x, mapX);\r\n        }\r\n\r\n        mapX.set(y, child);\r\n\r\n        return child;\r\n    }\r\n\r\n    private backpropagation(won: boolean) {\r\n        if (won) {\r\n            this.wins++;\r\n        }\r\n        this.visits++;\r\n        if (this.parent) {\r\n            this.parent.backpropagation(won);\r\n        }\r\n    }\r\n\r\n    public getBestChild() {\r\n        let bestNode: MctsNode | null = null;\r\n        let x: number = 0;\r\n        let y: number = 0;\r\n        let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n        let bestValue = -Infinity;\r\n        this.nodes.forEach((row, _orientation) => {\r\n            row.forEach((cell, _x) => {\r\n                cell.forEach((node, _y) => {\r\n                    const value = node.wins / node.visits;\r\n                    if (value > bestValue) {\r\n                        orientation = _orientation as \"vertical\" | \"horizontal\";\r\n                        x = +_x;\r\n                        y = +_y;\r\n                        bestValue = value;\r\n                        bestNode = node;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return { bestNode: bestNode!, x, y, orientation };\r\n    }\r\n\r\n    getNumberVisited() {\r\n        return this.visits;\r\n    }\r\n\r\n}","import { Board } from \"./board\";\r\nimport { MctsNode } from \"./mcts\";\r\nimport negamax from \"./negamax\";\r\nimport nigamax from \"./nigamax\";\r\n\r\nexport interface Coup {\r\n    x: number,\r\n    y: number,\r\n    orientation: \"vertical\" | \"horizontal\"\r\n}\r\n\r\nexport abstract class Player extends EventTarget {\r\n    protected totalTime: number = 0;\r\n    protected totalMove: number = 0;\r\n    protected times: number[] = [];\r\n\r\n    abstract play(board: Board, player: 0 | 1): Promise<Coup>\r\n}\r\n\r\nexport class HumanPlayer extends Player {\r\n    play(board: Board, player: 0 | 1) {\r\n        return new Promise<Coup>((resolve) => {\r\n            const start = performance.now()\r\n            this.addEventListener(\"play\", (e: Event) => {\r\n                const end = performance.now()\r\n                this.totalTime += end - start\r\n                this.totalMove++\r\n                this.times.push(end - start)\r\n                console.log(`Player ${player} (${(this as any).constructor.name}) Time: ${end - start} Average time: ${this.totalTime / this.totalMove}ms`)\r\n                const customEvent = e as CustomEvent<{ x: number, y: number, orientation: \"vertical\" | \"horizontal\" }>;\r\n                resolve(customEvent.detail);\r\n            }, { once: true })\r\n        })\r\n    }\r\n}\r\n\r\nexport abstract class iaPlayer extends Player {\r\n    async play(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return (await Promise.all([\r\n            (async (): Promise<Coup> => {\r\n                const start = performance.now()\r\n                const result = await this.playIa(board, player)\r\n                const end = performance.now()\r\n                this.totalTime += end - start\r\n                this.totalMove++\r\n                this.times.push(end - start)\r\n                console.log(`Player ${player} (${(this as any).constructor.name}) Time: ${end - start} Average time: ${this.totalTime / this.totalMove}ms`)\r\n                return result\r\n            })(),\r\n            //delay to see the move\r\n            new Promise<void>((resolve) => {\r\n                setTimeout(() => {\r\n                    resolve()\r\n                }, 500)\r\n            })\r\n        ]))[0]\r\n    }\r\n\r\n    abstract playIa(board: Board, player: number): Promise<Coup>;\r\n}\r\n\r\nexport class MctsPlayer extends iaPlayer {\r\n    private iteration: number;\r\n    private simulation: number;\r\n    private c: number\r\n    private lastBoard: Board | null = null;\r\n    private lastNode: MctsNode | null = null;\r\n\r\n    constructor({ iteration, simulation, c }: { iteration: number, simulation: number, c?: number }) {\r\n        super();\r\n        this.iteration = iteration;\r\n        this.simulation = simulation;\r\n        this.c = c || Math.sqrt(2);\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            let bestNode: MctsNode | null = null;\r\n            if (this.lastBoard && this.lastNode) {\r\n                const played = this.lastBoard\r\n                    .getHorizontals()\r\n                    .flatMap((row, y) => row.map((cell, x) => cell === -1 && board.getHorizontals()[y][x] !== -1 ? { x, y, orientation: \"horizontal\" } : null))\r\n                    .filter(x => x)\r\n                    .concat(\r\n                        this.lastBoard\r\n                            .getVerticals()\r\n                            .flatMap((row, y) => row.map((cell, x) => cell === -1 && board.getVerticals()[y][x] !== -1 ? { x, y, orientation: \"vertical\" } : null))\r\n                            .filter(x => x)\r\n                    ) as { x: number, y: number, orientation: \"vertical\" | \"horizontal\" }[]\r\n\r\n                if (played.length === 0) {\r\n                    bestNode = this.lastNode;\r\n                }\r\n\r\n\r\n                let bestValue = -Infinity;\r\n                if (played.length > 0) {\r\n                    for (const coup of permute(played)) {\r\n                        let currentNode: MctsNode | null = this.lastNode!.nodes.get(coup[0].orientation)?.get(coup[0].x)?.get(coup[0].y) || null;\r\n                        for (let i = 1; i < coup.length; i++) {\r\n                            currentNode = currentNode?.nodes.get(coup[i].orientation)?.get(coup[i].x)?.get(coup[i].y) || null;\r\n                            if (!currentNode) break;\r\n                        }\r\n                        if (currentNode) {\r\n                            if (currentNode.wins > bestValue) {\r\n                                bestValue = currentNode.wins;\r\n                                bestNode = currentNode;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            let root = bestNode || new MctsNode(board, player, this.simulation, this.c);\r\n            while (root.getNumberVisited() < this.iteration * this.simulation) {\r\n                root.run();\r\n            }\r\n            this.dispatchEvent(new CustomEvent(\"tree\", { detail: root }));\r\n            let bestChild = root.getBestChild();\r\n            this.lastNode = bestChild.bestNode;\r\n            this.lastBoard = board.play(bestChild.orientation, bestChild.x, bestChild.y);\r\n            resolve({ x: bestChild.x, y: bestChild.y, orientation: bestChild.orientation });\r\n        })\r\n    }\r\n}\r\n\r\nexport class RandomPlayer extends iaPlayer {\r\n    playIa(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            const { orientation, x, y } = board.getNodes().next().value!\r\n            resolve({ x, y, orientation });\r\n        })\r\n    }\r\n}\r\n\r\nexport class MinimaxPlayer extends iaPlayer {\r\n    private depth: number;\r\n\r\n    constructor({ depth }: { depth: number }) {\r\n        super();\r\n        this.depth = depth;\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            const { nodes, ...coup } = negamax(board, this.depth, true, player)\r\n            console.log(`Player ${player} (${(this as any).constructor.name}) : ${nodes} nodes`)\r\n            resolve(coup);\r\n        })\r\n    }\r\n}\r\n\r\nexport class FastestPlayer extends iaPlayer {\r\n    private depth: number;\r\n    private ias: (\"minimax\" | \"alphabeta\" | \"mcts\")[] = [\"minimax\", \"alphabeta\", \"mcts\"]\r\n\r\n    constructor({ depth }: { depth: number }) {\r\n        super();\r\n        this.depth = depth;\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1) {\r\n        const workers: Worker[] = []\r\n\r\n        return Promise.race(this.ias.map(ia => {\r\n            return new Promise<[Coup, typeof ia]>((resolve) => {\r\n                const worker = new Worker(new URL(\"../playerWorker.ts\", import.meta.url));\r\n                workers.push(worker)\r\n                worker.postMessage({ board: JSON.parse(JSON.stringify(board)), depth: this.depth, player, type: ia });\r\n                worker.addEventListener(\"message\", (e) => {\r\n                    resolve([e.data, ia]);\r\n                })\r\n            })\r\n        })).then(([coup, ia]) => {\r\n            workers.forEach(worker => worker.terminate())\r\n            console.log(ia)\r\n            return coup\r\n        })\r\n\r\n    }\r\n}\r\n\r\n\r\nexport class AlphaBetaPlayer extends iaPlayer {\r\n    private depth: number;\r\n\r\n    constructor({ depth }: { depth: number }) {\r\n        super();\r\n        this.depth = depth;\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1) {\r\n        return new Promise<Coup>((resolve) => {\r\n            const { nodes, ...coup } = nigamax(board, this.depth, true, player)\r\n            console.log(`Player ${player} (${(this as any).constructor.name}) : ${nodes} nodes`)\r\n            resolve(coup);\r\n        })\r\n    }\r\n}\r\n\r\n\r\nfunction permute<T>(arr: T[]): T[][] {\r\n    let results: T[][] = [];\r\n\r\n    function permuteRecursively(subArr: T[], memo: T[]) {\r\n        if (subArr.length === 0) {\r\n            results.push(memo.slice());\r\n        } else {\r\n            for (let i = 0; i < subArr.length; i++) {\r\n                let curr = subArr.slice();\r\n                let next = curr.splice(i, 1);\r\n                permuteRecursively(curr, memo.concat(next));\r\n            }\r\n        }\r\n    }\r\n\r\n    permuteRecursively(arr, []);\r\n    return results;\r\n}","import { Board, PlayerValue } from \"./board\";\r\n\r\nexport default function negamax(board: Board, _depth: number, maximizingPlayer: boolean, idPlayer: PlayerValue): {\r\n  x: number;\r\n  y: number;\r\n  value: number;\r\n  orientation: \"vertical\" | \"horizontal\";\r\n  nodes: number;\r\n} {\r\n  let x = 0, y = 0, orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n  let nodes = 0;\r\n  function _negamax(board: Board, depth: number, maximizingPlayer: boolean): number {\r\n    if (depth === 0 || board.isFinished())\r\n      return board.evaluation(idPlayer) * (maximizingPlayer ? 1 : -1)\r\n    let value = -Infinity;\r\n    for (const { board: node, x: _x, y: _y, orientation: _orientation } of board.getNodes()) {\r\n      nodes++;\r\n      const result = _negamax(node, depth - 1, !maximizingPlayer);\r\n      if (-result > value) {\r\n        if (depth === _depth) {\r\n          x = _x;\r\n          y = _y;\r\n          orientation = _orientation;\r\n        }\r\n        value = -result;\r\n      }\r\n    }\r\n    return value;\r\n  }\r\n  const value = _negamax(board, _depth, maximizingPlayer)\r\n\r\n  return {\r\n    x,\r\n    y,\r\n    orientation,\r\n    value,\r\n    nodes\r\n  };\r\n}","import { Board, PlayerValue } from \"./board\";\r\n\r\nexport default function nigamax(board: Board, _depth: number, maximizingPlayer: boolean, idPlayer: PlayerValue, alpha: number = -Infinity, beta: number = Infinity): {\r\n  x: number;\r\n  y: number;\r\n  value: number;\r\n  orientation: \"vertical\" | \"horizontal\";\r\n  nodes: number;\r\n} {\r\n  let x = 0, y = 0, orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n  let nodes = 0;\r\n  function _nigamax(board: Board, depth: number, maximizingPlayer: boolean, alpha: number = -Infinity, beta: number = Infinity): number {\r\n    if (depth === 0 || board.isFinished()) {\r\n      return board.evaluation(idPlayer) * (maximizingPlayer ? 1 : -1)\r\n    }\r\n    let value = -Infinity;\r\n    for (const { board: node, x: _x, y: _y, orientation: _orientation } of board.getNodes()) {\r\n      nodes++;\r\n      const result = _nigamax(node, depth - 1, !maximizingPlayer, -beta, -alpha);\r\n      if (-result > value) {\r\n        value = -result;\r\n        if (depth === _depth) {\r\n          x = _x;\r\n          y = _y;\r\n          orientation = _orientation;\r\n        }\r\n      }\r\n      if (value >= beta) {\r\n        return value\r\n      }\r\n      alpha = Math.max(alpha, value);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  const value = _nigamax(board, _depth, maximizingPlayer, alpha, beta)\r\n  return {\r\n    value,\r\n    x,\r\n    y,\r\n    orientation,\r\n    nodes\r\n  };\r\n}\r\n","import { MainToWorkerEventMap } from \"./@types/worker\";\r\nimport { PlayerValue, PlayValue } from \"./utils/board\";\r\nimport Game from \"./utils/game\";\r\nimport { AlphaBetaPlayer, FastestPlayer, HumanPlayer, MctsPlayer, MinimaxPlayer, RandomPlayer } from \"./utils/player\";\r\n\r\ndeclare var self: DedicatedWorkerGlobalScope;\r\n\r\nDedicatedWorkerGlobalScope.prototype.emit = function (...data) {\r\n    this.postMessage({ type: data[0], data: data[1] });\r\n}\r\n\r\nself.addEventListener(\"message\", ({ data: { data, type } }) => {\r\n    self.dispatchEvent(new CustomEvent(type, {\r\n        detail: data\r\n    }));\r\n});\r\n\r\nlet game: Game | null = null;\r\n\r\ntype Node = {\r\n    visits: number,\r\n    wins: number,\r\n    nodes: Map<string, Map<number, Map<number, Node>>>\r\n}\r\n\r\ntype Data = {\r\n    name: string,\r\n    children: Data[]\r\n}\r\n\r\nfunction formatNode(node: Node): Data {\r\n    const children = new Array<Data>();\r\n    node.nodes.forEach((row, orientation) => {\r\n        row.forEach((cell, x) => {\r\n            cell.forEach((node, y) => {\r\n                children.push(formatNode(node));\r\n            });\r\n        });\r\n    });\r\n\r\n    return {\r\n        name: `${node.wins}/${node.visits}`,\r\n        children\r\n    }\r\n\r\n}\r\n\r\nself.addEventListener(\"start\", ({ detail: { player1, player2, size } }) => {\r\n    if (game) return;\r\n\r\n    const player1Instance = createPlayer(player1);\r\n    const player2Instance = createPlayer(player2);\r\n\r\n    player1Instance.addEventListener(\"tree\", (e) => {\r\n        self.emit(\"tree\", {\r\n            player: 1,\r\n            tree: formatNode((e as CustomEvent<Node>).detail)\r\n        });\r\n    });\r\n\r\n    player2Instance.addEventListener(\"tree\", (e) => {\r\n        self.emit(\"tree\", {\r\n            player: 2,\r\n            tree: formatNode((e as CustomEvent<Node>).detail)\r\n        });\r\n    });\r\n\r\n\r\n    game = new Game(size, player1Instance, player2Instance);\r\n\r\n    if (player1Instance instanceof HumanPlayer) {\r\n        self.addEventListener(\"play\", (e) => {\r\n            player1Instance.dispatchEvent(new CustomEvent(\"play\", {\r\n                detail: e.detail\r\n            }));\r\n        });\r\n    }\r\n\r\n    if (player2Instance instanceof HumanPlayer) {\r\n        self.addEventListener(\"play\", (e) => {\r\n            player2Instance.dispatchEvent(new CustomEvent(\"play\", {\r\n                detail: e.detail\r\n            }));\r\n        });\r\n    }\r\n\r\n    self.emit(\"change\", {\r\n        verticals: game.getBoard().getVerticals(),\r\n        horizontals: game.getBoard().getHorizontals(),\r\n        score: game.getBoard().getScore(),\r\n        tour: game.getBoard().getTour(),\r\n        cells: game.getBoard().getCells()\r\n    });\r\n\r\n    game.addEventListener(\"end\", (e) => {\r\n        const { winner } = (\r\n            e as CustomEvent<{\r\n                winner: PlayerValue\r\n            }>\r\n        ).detail;\r\n        self.emit(\"end\", {\r\n            winner\r\n        });\r\n    });\r\n\r\n    game.addEventListener(\"played\", (e) => {\r\n        const { board: {\r\n            cells,\r\n            verticals,\r\n            horizontals,\r\n            player,\r\n            score\r\n        } } = (\r\n            e as CustomEvent<{\r\n                played: {\r\n                    x: number;\r\n                    y: number;\r\n                    orientation: string;\r\n                    player: PlayerValue;\r\n                };\r\n                board: {\r\n                    verticals: ReadonlyArray<ReadonlyArray<PlayValue>>;\r\n                    horizontals: ReadonlyArray<ReadonlyArray<PlayValue>>;\r\n                    cells: ReadonlyArray<ReadonlyArray<PlayValue>>;\r\n                    score: readonly [number, number];\r\n                    player: PlayerValue;\r\n                };\r\n            }>\r\n        ).detail;\r\n\r\n        self.emit(\"change\", {\r\n            verticals,\r\n            horizontals,\r\n            score: score,\r\n            tour: player,\r\n            cells\r\n        });\r\n    });\r\n\r\n    game.start().then(() => {\r\n        self.emit(\"end\", {\r\n            winner: game!.getBoard().getWinner()\r\n        });\r\n    });\r\n});\r\n\r\n\r\nfunction createPlayer(player: MainToWorkerEventMap[\"start\"][\"detail\"][\"player1\"]) {\r\n    switch (player.type) {\r\n        case \"human\":\r\n            return new HumanPlayer();\r\n        case \"random\":\r\n            return new RandomPlayer();\r\n        case \"minimax\":\r\n            return new MinimaxPlayer(player);\r\n        case \"alphabeta\":\r\n            return new AlphaBetaPlayer(player);\r\n        case \"mcts\":\r\n            return new MctsPlayer(player);\r\n        case \"fastest\":\r\n            return new FastestPlayer(player);\r\n    }\r\n}\r\n\r\n\r\nexport { };\r\n\r\n"],"names":["__webpack_require__","chunkId","obj","prop","Object","prototype","hasOwnProperty","call","b","self","location","Board","constructor","BoardOrSize","cells","verticals","horizontals","previousBoard","score","tour","this","Array","fill","map","getCells","getVerticals","getHorizontals","getScore","getWinner","length","getTour","play","orientation","x","y","newHorizontals","row","newVerticals","newCells","newScore","newTour","Error","result","check","push","forEach","cell","isFinished","_horizontals","evaluation","idPlayer","getNodes","playable","flatMap","value","filter","_ref","_ref2","splice","Math","floor","random","board","node","Game","EventTarget","size","player1","player2","super","players","getBoard","then","coup","newBoard","dispatchEvent","CustomEvent","detail","played","player","winner","start","MctsNode","simulation","c","parent","arguments","undefined","wins","visits","nodes","generator","Map","run","i","backpropagation","simulate","newChild","expansion","bestNode","selection","bestValue","Infinity","_orientation","_x","_y","sqrt","log","gen","done","next","child","mapOrientation","get","set","mapX","won","getBestChild","getNumberVisited","Player","totalTime","totalMove","times","HumanPlayer","Promise","resolve","performance","now","addEventListener","e","end","console","name","once","iaPlayer","all","playIa","setTimeout","MctsPlayer","iteration","lastBoard","lastNode","concat","arr","results","permuteRecursively","subArr","memo","slice","curr","permute","_nodes$get","_nodes$get$get","currentNode","_currentNode","_currentNode$nodes$ge","_currentNode$nodes$ge2","root","bestChild","RandomPlayer","MinimaxPlayer","depth","_depth","maximizingPlayer","_negamax","negamax","FastestPlayer","_ref3","ias","workers","race","ia","worker","Worker","URL","postMessage","JSON","parse","stringify","type","data","_ref4","terminate","AlphaBetaPlayer","_ref5","_nigamax","alpha","beta","max","nigamax","DedicatedWorkerGlobalScope","emit","game","formatNode","children","createPlayer","player1Instance","player2Instance","tree"],"sourceRoot":""}