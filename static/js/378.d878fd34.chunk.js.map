{"version":3,"file":"static/js/378.d878fd34.chunk.js","mappings":"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","sources":["../webpack/bootstrap","../webpack/runtime/get javascript chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","utils/board.ts","utils/game.ts","utils/players/Player.ts","utils/players/IAPlayer.ts","utils/players/AlphaBetaPlayer.ts","utils/nigamax.ts","utils/players/FastestPlayer.ts","utils/players/HumanPlayer.ts","utils/mcts.ts","utils/players/MCTSPlayer.ts","utils/players/MinimaxPlayer.ts","utils/negamax.ts","utils/players/RandomPlayer.ts","worker.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"aea85cc4\" + \".chunk.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/POLYTECH-IA-PROJET-PIPOPIPETTE/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t378: 1\n};\n\n// no chunk install function needed\n// no chunk loading\n\n// no HMR\n\n// no HMR manifest","export type NodeGenerator = Generator<\r\n    {\r\n        x: number;\r\n        y: number;\r\n        board: Board;\r\n        orientation: \"vertical\" | \"horizontal\";\r\n    },\r\n    void,\r\n    void\r\n>;\r\n\r\nexport interface Coup {\r\n    x: number,\r\n    y: number,\r\n    orientation: \"vertical\" | \"horizontal\"\r\n}\r\n\r\nexport type PlayValue = -1 | 0 | 1;\r\nexport type PlayerValue = 0 | 1;\r\n\r\nexport class Board {\r\n    readonly cells: ReadonlyArray<ReadonlyArray<PlayValue>> = [];\r\n    readonly verticals: ReadonlyArray<ReadonlyArray<PlayValue>> = [];\r\n    readonly horizontals: ReadonlyArray<ReadonlyArray<PlayValue>> = [];\r\n    readonly previousBoard: Board | null = null;\r\n    readonly score: readonly [number, number] = [0, 0];\r\n    readonly tour: PlayerValue = 0;\r\n\r\n    constructor(size: number);\r\n    constructor(board: { cells: PlayValue[][]; verticals: PlayValue[][]; horizontals: PlayValue[][]; score: [number, number]; tour: PlayerValue, previousBoard?: Board });\r\n    constructor(BoardOrSize: number | { cells: PlayValue[][]; verticals: PlayValue[][]; horizontals: PlayValue[][]; score: [number, number]; tour: PlayerValue, previousBoard?: Board }) {\r\n        if (typeof BoardOrSize === \"number\") {\r\n            this.cells = new Array(BoardOrSize).fill(0).map(() => new Array(BoardOrSize).fill(-1));\r\n            this.verticals = new Array(BoardOrSize)\r\n                .fill(0)\r\n                .map(() => new Array(BoardOrSize + 1).fill(-1));\r\n            this.horizontals = new Array(BoardOrSize + 1)\r\n                .fill(0)\r\n                .map(() => new Array(BoardOrSize).fill(-1));\r\n            this.score = [0, 0];\r\n            this.tour = 0;\r\n        } else {\r\n            this.cells = BoardOrSize.cells;\r\n            this.verticals = BoardOrSize.verticals;\r\n            this.horizontals = BoardOrSize.horizontals;\r\n            this.score = BoardOrSize.score;\r\n            this.tour = BoardOrSize.tour;\r\n            this.previousBoard = BoardOrSize.previousBoard || null;\r\n        }\r\n    }\r\n\r\n    public getWinner(): -1 | 0 | 1 {\r\n        return this.score[0] > this.score[1] ? 0 : this.score[0] < this.score[1] ? 1 : -1;\r\n    }\r\n\r\n    public play(\r\n        orientation: \"vertical\" | \"horizontal\",\r\n        x: number,\r\n        y: number\r\n    ): Board | null {\r\n\r\n        const newHorizontals = this.horizontals.map((row) => [...row]);\r\n        const newVerticals = this.verticals.map((row) => [...row]);\r\n        const newCells = this.cells.map((row) => [...row]);\r\n        const newScore = [...this.score];\r\n        let newTour = this.tour;\r\n\r\n        if (orientation === \"vertical\") {\r\n            if (newVerticals[y][x] !== -1) {\r\n                console.error(\"Invalid move \" + orientation + x + y)\r\n                return null;\r\n            }\r\n            newVerticals[y][x] = this.tour;\r\n        } else {\r\n            if (newHorizontals[y][x] !== -1) {\r\n                console.error(\"Invalid move \" + orientation + x + y);\r\n                return null;\r\n            }\r\n            newHorizontals[y][x] = this.tour;\r\n\r\n\r\n        }\r\n\r\n        const cells: Array<[x: number, y: number]> = [];\r\n\r\n        if (orientation === \"horizontal\") {\r\n            let result = this.check(newHorizontals, newVerticals, x, y);\r\n            if (result) cells.push(result);\r\n            result = this.check(newHorizontals, newVerticals, x, y - 1);\r\n            if (result) cells.push(result);\r\n        } else {\r\n            let result = this.check(newHorizontals, newVerticals, x, y);\r\n            if (result) cells.push(result);\r\n            result = this.check(newHorizontals, newVerticals, x - 1, y);\r\n            if (result) cells.push(result);\r\n        }\r\n\r\n        if (!cells.length) {\r\n            newTour = newTour === 1 ? 0 : 1;\r\n        } else {\r\n            newScore[newTour] += cells.length;\r\n\r\n            cells.forEach((cell) => {\r\n                newCells[cell[1]][cell[0]] = newTour;\r\n            });\r\n        }\r\n\r\n        return new Board({\r\n            cells: newCells,\r\n            verticals: newVerticals,\r\n            horizontals: newHorizontals,\r\n            score: newScore as [number, number],\r\n            tour: newTour,\r\n            previousBoard: this\r\n        });\r\n    }\r\n\r\n    public isFinished() {\r\n        return this.score[0] > this.cells.length ** 2 / 2 || this.score[1] > this.cells.length ** 2 / 2 || this.score[0] + this.score[1] === this.cells.length ** 2;\r\n    }\r\n\r\n    private check(horizontals: PlayValue[][], verticals: PlayValue[][], x: number, y: number): false | [x: number, y: number] {\r\n        if (x < 0 || x >= this.cells.length || y < 0 || y >= this.cells.length) {\r\n            return false;\r\n        }\r\n        if (\r\n            verticals[y][x] !== -1 &&\r\n            verticals[y][x + 1] !== -1 &&\r\n            horizontals[y][x] !== -1 &&\r\n            horizontals[y + 1]?.[x] !== -1\r\n        ) {\r\n            return [x, y];\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public evaluation(idPlayer: PlayerValue) {\r\n        return this.score[idPlayer] - this.score[idPlayer === 1 ? 0 : 1];\r\n    }\r\n\r\n\r\n    public *getNodes(depthLimit?: number): NodeGenerator {\r\n        const playable = [\r\n            ...this.verticals\r\n                .flatMap((row, y) => row.map((value, x) => ({ x, y, value, orientation: \"vertical\" } satisfies Coup & { value: number })))\r\n                .filter(({ value }) => value === -1),\r\n            ...this.horizontals\r\n                .flatMap((row, y) => row.map((value, x) => ({ x, y, value, orientation: \"horizontal\" } satisfies Coup & { value: number })))\r\n                .filter(({ value }) => value === -1)\r\n        ]\r\n\r\n        let currentIndex = playable.length;\r\n        while (currentIndex !== 0) {\r\n\r\n            let randomIndex = Math.floor(Math.random() * currentIndex);\r\n            currentIndex--;\r\n\r\n            // And swap it with the current element.\r\n            [playable[currentIndex], playable[randomIndex]] = [\r\n                playable[randomIndex], playable[currentIndex]];\r\n        }\r\n\r\n        for (let i = 0; i < playable.length; i++) {\r\n            const { x, y, orientation } = playable[i];\r\n            const board = this.play(orientation, x, y)!;\r\n            if (board.tour === board.previousBoard!.tour && !board.isFinished() && (depthLimit === undefined || depthLimit > 0)) {\r\n                for (const node of board.getNodes(depthLimit ? depthLimit - 1 : undefined)) {\r\n                    yield { ...node, x, y, orientation };\r\n                }\r\n            } else yield { x, y, board, orientation };\r\n        }\r\n    }\r\n}\r\n\r\n\r\n","import { Board } from \"./board\";\r\nimport { Player } from \"./players/Player\";\r\nexport default class Game extends EventTarget {\r\n  private board: Board;\r\n  private players: [Player, Player];\r\n  private playing: boolean = false;\r\n\r\n  constructor(size: number, player1: Player, player2: Player) {\r\n    super();\r\n    this.board = new Board(size);\r\n    this.players = [player1, player2];\r\n    this.play();\r\n  }\r\n\r\n  getBoard() {\r\n    return this.board;\r\n  }\r\n\r\n  private async play() {\r\n    if (this.playing) return;\r\n    this.playing = true;\r\n    while (!this.board.isFinished()) {\r\n      await this.players[this.board.tour].play(this.board, this.board.tour).then((coup) => {\r\n        const newBoard = this.board.play(coup.orientation, coup.x, coup.y)\r\n        if (newBoard) {\r\n          this.board = newBoard;\r\n          this.dispatchEvent(new CustomEvent(\"played\", {\r\n            detail: {\r\n              played: {\r\n                x: coup.x, y: coup.y, orientation: coup.orientation, player: newBoard.previousBoard!.tour\r\n              },\r\n              board: this.board\r\n            }\r\n          }));\r\n        }\r\n      });\r\n    }\r\n    const [player1, player2] = this.board.score\r\n\r\n    this.dispatchEvent(new CustomEvent(\"end\", {\r\n      detail: {\r\n        winner: player1 > player2 ? 0 : player1 < player2 ? 1 : -1\r\n      }\r\n    }));\r\n  }\r\n\r\n  public async start() {\r\n    await this.play();\r\n  }\r\n}\r\n","import { Board, Coup, PlayerValue } from \"../board\";\r\n\r\n/**\r\n * Classe abstraite représentant un joueur dans le jeu.\r\n * Étend la classe EventTarget pour gérer les événements.\r\n */\r\nexport abstract class Player extends EventTarget {\r\n    /**\r\n     * Le temps total pris par le joueur.\r\n     */\r\n    protected totalTime: number = 0;\r\n\r\n    /**\r\n     * Le nombre total de mouvements effectués par le joueur.\r\n     */\r\n    protected totalMove: number = 0;\r\n\r\n    /**\r\n     * Un tableau pour stocker les temps pris pour chaque mouvement.\r\n     */\r\n    protected times: number[] = [];\r\n\r\n    /**\r\n     * Méthode abstraite à implémenter par les sous-classes pour effectuer un mouvement.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    abstract play(board: Board, player: PlayerValue): Promise<Coup>;\r\n}\r\n","import { Board, Coup, PlayerValue } from \"../board\";\r\nimport { Player } from \"./Player\";\r\n\r\n/**\r\n * Classe abstraite représentant un joueur IA.\r\n */\r\nexport abstract class IaPlayer extends Player {\r\n\r\n    /**\r\n     * Le temps minimal pour jouer un coup.\r\n     */\r\n    protected minTimeToPlay: number = 0;\r\n\r\n\r\n    /**\r\n     * \r\n     * @param {number} minTimeToPlay - Le temps minimal pour jouer un coup.\r\n     */\r\n    constructor({ minTimeToPlay }: { minTimeToPlay?: number }) {\r\n        super()\r\n        this.minTimeToPlay = minTimeToPlay || 500;\r\n    }\r\n\r\n    /**\r\n     * Joue un coup sur le plateau.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    async play(board: Board, player: PlayerValue): Promise<Coup> {\r\n        return (await Promise.all([\r\n            new Promise<Coup>(async (resolve) => {\r\n                const start = performance.now();\r\n                const result = await this.playIa(board, player);\r\n                const end = performance.now();\r\n\r\n                this.totalTime += end - start;\r\n                this.totalMove++;\r\n                this.times.push(end - start);\r\n\r\n                console.log(`Player ${player} (${this.constructor.name}) Time: ${end - start}ms Average time: ${this.totalTime / this.totalMove}ms`);\r\n\r\n                resolve(result);\r\n            }),\r\n            //Temps minimal de pour jouer\r\n            new Promise<void>((resolve) => setTimeout(resolve, this.minTimeToPlay))\r\n        ]))[0]\r\n    }\r\n\r\n    /**\r\n     * Méthode abstraite pour jouer un coup IA.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    abstract playIa(board: Board, player: PlayerValue): Promise<Coup>;\r\n}","import { Board, Coup, PlayerValue } from \"../board\";\r\nimport nigamax from \"../nigamax\";\r\nimport { IaPlayer } from \"./IAPlayer\";\r\n\r\nexport class AlphaBetaPlayer extends IaPlayer {\r\n    private depth: number;\r\n\r\n    private depthLimit?: number;\r\n\r\n    constructor(paramters: { depth: number, minTimeToPlay?: number, depthLimit?: number }) {\r\n        super(paramters);\r\n        this.depth = paramters.depth;\r\n        this.depthLimit = paramters.depthLimit;\r\n    }\r\n\r\n    playIa(board: Board, player: PlayerValue) {\r\n        return new Promise<Coup>((resolve) => {\r\n            const { nodes, ...coup } = nigamax(board, this.depth, player, this.depthLimit)\r\n            console.log(`Player ${player} (${(this as any).constructor.name}) : ${nodes} nodes`)\r\n            resolve(coup);\r\n        })\r\n    }\r\n}\r\n\r\n","import { Board, Coup, PlayerValue } from \"./board\";\r\n\r\nexport default function nigamax(board: Board, _depth: number, idPlayer: PlayerValue, depthLimit?: number): Coup & {\r\n  nodes: number;\r\n  value: number;\r\n} {\r\n  let coup: Coup = { x: 0, y: 0, orientation: \"horizontal\" };\r\n  let nodes = 0;\r\n\r\n  //key is horizontals stringified + verticals stringified + score stringified + nextPlayer stringified\r\n  //value is the evaluation\r\n  const history = new Map<string, number>();\r\n\r\n  function generateKey(board: Board): string {\r\n    return `${board.horizontals.map(h => h.map(e => e !== -1 ? 1 : 0).join(\"\")).join(\"\")}${board.verticals.map(h => h.map(e => e !== -1 ? 1 : 0).join(\"\")).join(\"\")}${board.score.join(\"\")}${board.tour}`;\r\n  }\r\n\r\n\r\n  function _nigamax(board: Board, depth: number, maximizingPlayer: boolean, alpha: number = -Infinity, beta: number = Infinity): number {\r\n    if (depth === 0 || board.isFinished())\r\n      return board.evaluation(idPlayer) * (maximizingPlayer ? 1 : -1)\r\n\r\n    let value = -Infinity;\r\n\r\n    for (const { board: node, ...coupPlayed } of board.getNodes(depthLimit)) {\r\n      nodes++;\r\n      const key = generateKey(node);\r\n\r\n      if (history.has(key)) {\r\n        value = Math.max(value, history.get(generateKey(node))!);\r\n      }\r\n      else {\r\n        const result = _nigamax(node, depth - 1, !maximizingPlayer, -beta, -alpha);\r\n        history.set(key, -result);\r\n\r\n        if (-result > value) {\r\n          if (depth === _depth) coup = coupPlayed\r\n          value = -result;\r\n        }\r\n      }\r\n\r\n      if (value >= beta) return value\r\n\r\n      alpha = Math.max(alpha, value);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  const value = _nigamax(board, _depth, true)\r\n\r\n  return {\r\n    value,\r\n    ...coup,\r\n    nodes\r\n  };\r\n}\r\n","import { Board, Coup, PlayerValue } from \"../board\";\r\nimport { AlphaBetaPlayer } from \"./AlphaBetaPlayer\";\r\nimport { IaPlayer } from \"./IAPlayer\";\r\nimport { MctsPlayer } from \"./MCTSPlayer\";\r\nimport { MinimaxPlayer } from \"./MinimaxPlayer\";\r\n\r\n\r\n/**\r\n * Classe représentant un joueur IA qui est un sous ensemble des joueurs IA. Dans ce cas se sont \"minimax\", \"alphabeta\" et \"mcts\".\r\n * @extends IaPlayer\r\n */\r\nexport class FastestPlayer extends IaPlayer {\r\n\r\n    readonly parameters: ConstructorParameters<typeof MinimaxPlayer>[0] & ConstructorParameters<typeof AlphaBetaPlayer>[0] & ConstructorParameters<typeof MctsPlayer>[0]\r\n\r\n    /*\r\n     * Les IA à jouer.\r\n     */\r\n    readonly ias: (\"minimax\" | \"alphabeta\" | \"mcts\")[] = [\"minimax\", \"alphabeta\", \"mcts\"]\r\n\r\n    /**\r\n     * \r\n     * @param {number} depth - La profondeur de recherche.\r\n     */\r\n    constructor(parameters: ConstructorParameters<typeof MinimaxPlayer>[0] & ConstructorParameters<typeof AlphaBetaPlayer>[0] & ConstructorParameters<typeof MctsPlayer>[0]) {\r\n        super(parameters);\r\n        this.parameters = parameters;\r\n    }\r\n\r\n    /**\r\n     * Joue un coup sur le plateau.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    async playIa(board: Board, player: PlayerValue): Promise<Coup> {\r\n        const workers: Worker[] = []\r\n\r\n        const [coup, ia_1] = await Promise.race(this.ias.map(ia => {\r\n            return new Promise<[Coup, typeof ia]>((resolve) => {\r\n                const worker = new Worker(new URL(\"../playerWorker.ts\", import.meta.url));\r\n                workers.push(worker);\r\n                worker.postMessage({ board: JSON.parse(JSON.stringify(board)), parameters: this.parameters, player, type: ia });\r\n                worker.addEventListener(\"message\", (e) => {\r\n                    resolve([e.data, ia]);\r\n                });\r\n            });\r\n        }));\r\n        workers.forEach(w => w.terminate());\r\n        console.log(`Player ${player} (${ia_1})`)\r\n        return coup;\r\n    }\r\n}\r\n","import { Board, Coup, PlayerValue } from \"../board\"\r\nimport { Player } from \"./Player\"\r\n\r\n/**\r\n * Classe représentant un joueur humain.\r\n * @extends Player\r\n */\r\nexport class HumanPlayer extends Player {\r\n\r\n    /**\r\n     * Joue un coup sur le plateau.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    play(board: Board, player: PlayerValue): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            const start = performance.now()\r\n            this.addEventListener(\"play\", (e: Event) => {\r\n                const end = performance.now()\r\n                this.totalTime += end - start\r\n                this.totalMove++\r\n                this.times.push(end - start)\r\n                console.log(`Player ${player} (${this.constructor.name}) Time: ${end - start} Average time: ${this.totalTime / this.totalMove}ms`)\r\n                const customEvent = e as CustomEvent<Coup>;\r\n                resolve(customEvent.detail);\r\n            }, { once: true })\r\n        })\r\n    }\r\n}","import { Board } from \"./board\";\r\n\r\nexport class MctsNode {\r\n    public wins: number;\r\n    public visits: number;\r\n    public nodes: Map<\"vertical\" | \"horizontal\", Map<number, Map<number, MctsNode>>>;\r\n    public parent: MctsNode | null;\r\n    private board: Board;\r\n    private player: 0 | 1;\r\n    private simulation: number;\r\n    private c: number\r\n    private generator: Generator<{ orientation: \"vertical\" | \"horizontal\"; x: number; y: number, board: Board }, void, unknown>;\r\n\r\n    constructor(board: Board, player: 0 | 1, simulation: number, c: number, parent: MctsNode | null = null) {\r\n        this.wins = 0;\r\n        this.visits = 0;\r\n        this.nodes = new Map();\r\n        this.parent = parent;\r\n        this.generator = board.getNodes();\r\n        this.board = board;\r\n        this.simulation = simulation;\r\n        this.player = player;\r\n        this.c = c;\r\n    }\r\n\r\n\r\n    public run() {\r\n        if (this.board.isFinished()) {\r\n            for (let i = 0; i < this.simulation; i++) {\r\n                this.backpropagation(this.simulate());\r\n            }\r\n            return\r\n        }\r\n\r\n        let newChild = this.expansion()\r\n\r\n        if (newChild) {\r\n            for (let i = 0; i < this.simulation; i++) {\r\n                newChild.backpropagation(newChild.simulate());\r\n            }\r\n        }\r\n        else {\r\n            const { bestNode } = this.selection();\r\n            bestNode.run();\r\n        }\r\n    }\r\n\r\n    private selection(): {\r\n        bestNode: MctsNode;\r\n        x: number;\r\n        y: number;\r\n        orientation: \"vertical\" | \"horizontal\";\r\n    } {\r\n        let bestNode: MctsNode | null = null;\r\n        let x: number = 0;\r\n        let y: number = 0;\r\n        let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n        let bestValue = -Infinity;\r\n        this.nodes.forEach((row, _orientation) => {\r\n            row.forEach((cell, _x) => {\r\n                cell.forEach((node, _y) => {\r\n                    const value = node.wins / node.visits + this.c * Math.sqrt(2 * Math.log(this.visits) / node.visits);\r\n                    if (value > bestValue) {\r\n                        bestValue = value;\r\n                        orientation = _orientation as \"vertical\" | \"horizontal\";\r\n                        x = +_x;\r\n                        y = +_y;\r\n                        bestNode = node;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return { bestNode: bestNode!, x, y, orientation };\r\n    }\r\n\r\n    private simulate() {\r\n        let board = this.board;\r\n        while (true) {\r\n            const { value, done } = board.getNodes().next();\r\n            if (done) break;\r\n            board = value.board\r\n        }\r\n        return board.getWinner() === this.player;\r\n    }\r\n\r\n    private expansion() {\r\n        const { value, done } = this.generator.next();\r\n\r\n        if (done) return false;\r\n\r\n        const { orientation, x, y, board } = value;\r\n        const child = new MctsNode(board, this.player, this.simulation, this.c, this);\r\n        let mapOrientation = this.nodes.get(orientation);\r\n        if (!mapOrientation) {\r\n            mapOrientation = new Map();\r\n            this.nodes.set(orientation, mapOrientation);\r\n        }\r\n\r\n        let mapX = mapOrientation.get(x);\r\n        if (!mapX) {\r\n            mapX = new Map();\r\n            mapOrientation.set(x, mapX);\r\n        }\r\n\r\n        mapX.set(y, child);\r\n\r\n        return child;\r\n    }\r\n\r\n    private backpropagation(won: boolean) {\r\n        if (won) {\r\n            this.wins++;\r\n        }\r\n        this.visits++;\r\n        if (this.parent) {\r\n            this.parent.backpropagation(won);\r\n        }\r\n    }\r\n\r\n    public getBestChild() {\r\n        let bestNode: MctsNode | null = null;\r\n        let x: number = 0;\r\n        let y: number = 0;\r\n        let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n        let bestValue = -Infinity;\r\n        this.nodes.forEach((row, _orientation) => {\r\n            row.forEach((cell, _x) => {\r\n                cell.forEach((node, _y) => {\r\n                    const value = node.wins / node.visits;\r\n                    if (value > bestValue) {\r\n                        orientation = _orientation as \"vertical\" | \"horizontal\";\r\n                        x = +_x;\r\n                        y = +_y;\r\n                        bestValue = value;\r\n                        bestNode = node;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return { bestNode: bestNode!, x, y, orientation };\r\n    }\r\n\r\n    getNumberVisited() {\r\n        return this.visits;\r\n    }\r\n\r\n}","import { Board, Coup, PlayerValue } from \"../board\";\r\nimport { MctsNode } from \"../mcts\";\r\nimport { IaPlayer } from \"./IAPlayer\";\r\n\r\n/**\r\n * Classe représentant un joueur IA qui joue avec l'algorithme MCTS.\r\n * @extends IaPlayer\r\n */\r\nexport class MctsPlayer extends IaPlayer {\r\n\r\n    /**\r\n     * Le nombre d'itérations\r\n     */\r\n    private iteration: number;\r\n\r\n    /**\r\n     * Le nombre de simulations par itération.\r\n     */\r\n    private simulation: number;\r\n\r\n    /**\r\n     * La constante C pour l'exploration.\r\n     */\r\n    private c: number\r\n\r\n    /**\r\n     * Le dernier plateau joué.\r\n     */\r\n    private lastBoard: Board | null = null;\r\n\r\n    /**\r\n     * Le dernier noeud joué.\r\n     */\r\n    private lastNode: MctsNode | null = null;\r\n\r\n\r\n    /**\r\n     * \r\n     * @param {number} iteration - Le nombre d'itérations.\r\n     * @param {number} simulation - Le nombre de simulations par itération.\r\n     * @param {number} c - La constante C pour l'exploration.\r\n     * @param {number} minTimeToPlay - Le temps minimal pour jouer un coup.\r\n     */\r\n    constructor(parameters: { iteration: number, simulation: number, c?: number, minTimeToPlay?: number }) {\r\n        super(parameters);\r\n        this.iteration = parameters.iteration;\r\n        this.simulation = parameters.simulation;\r\n        this.c = parameters.c || Math.sqrt(2);\r\n    }\r\n\r\n\r\n    /**\r\n     * Joue un coup sur le plateau.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    playIa(board: Board, player: PlayerValue): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            let bestNode: MctsNode | null = null;\r\n            if (this.lastBoard && this.lastNode) {\r\n                const played = this.lastBoard\r\n                    .horizontals\r\n                    .flatMap((row, y) => row.map((cell, x) => cell === -1 && board.horizontals[y][x] !== -1 ? { x, y, orientation: \"horizontal\" } : null))\r\n                    .filter(x => x)\r\n                    .concat(\r\n                        this.lastBoard\r\n                            .verticals\r\n                            .flatMap((row, y) => row.map((cell, x) => cell === -1 && board.verticals[y][x] !== -1 ? { x, y, orientation: \"vertical\" } : null))\r\n                            .filter(x => x)\r\n                    ) as { x: number, y: number, orientation: \"vertical\" | \"horizontal\" }[]\r\n\r\n                if (played.length === 0) {\r\n                    bestNode = this.lastNode;\r\n                }\r\n\r\n\r\n                let bestValue = -Infinity;\r\n                if (played.length > 0) {\r\n                    for (const coup of permute(played)) {\r\n                        let currentNode: MctsNode | null = this.lastNode!.nodes.get(coup[0].orientation)?.get(coup[0].x)?.get(coup[0].y) || null;\r\n                        for (let i = 1; i < coup.length; i++) {\r\n                            currentNode = currentNode?.nodes.get(coup[i].orientation)?.get(coup[i].x)?.get(coup[i].y) || null;\r\n                            if (!currentNode) break;\r\n                        }\r\n                        if (currentNode) {\r\n                            if (currentNode.wins > bestValue) {\r\n                                bestValue = currentNode.wins;\r\n                                bestNode = currentNode;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            let root = bestNode || new MctsNode(board, player, this.simulation, this.c);\r\n            while (root.getNumberVisited() < this.iteration * this.simulation) {\r\n                root.run();\r\n            }\r\n            this.dispatchEvent(new CustomEvent(\"tree\", { detail: root }));\r\n            let bestChild = root.getBestChild();\r\n            this.lastNode = bestChild.bestNode;\r\n            this.lastBoard = board.play(bestChild.orientation, bestChild.x, bestChild.y);\r\n            resolve({ x: bestChild.x, y: bestChild.y, orientation: bestChild.orientation });\r\n        })\r\n    }\r\n}\r\n\r\n\r\nfunction permute<T>(arr: T[]): T[][] {\r\n    let results: T[][] = [];\r\n\r\n    function permuteRecursively(subArr: T[], memo: T[]) {\r\n        if (subArr.length === 0) {\r\n            results.push(memo.slice());\r\n        } else {\r\n            for (let i = 0; i < subArr.length; i++) {\r\n                let curr = subArr.slice();\r\n                let next = curr.splice(i, 1);\r\n                permuteRecursively(curr, memo.concat(next));\r\n            }\r\n        }\r\n    }\r\n\r\n    permuteRecursively(arr, []);\r\n    return results;\r\n}","import { Board, Coup } from \"../board\";\r\nimport negamax from \"../negamax\";\r\nimport { IaPlayer } from \"./IAPlayer\";\r\n\r\nexport class MinimaxPlayer extends IaPlayer {\r\n    private depth: number;\r\n\r\n    private depthLimit?: number;\r\n\r\n    constructor(paramters: { depth: number, minTimeToPlay?: number, depthLimit?: number }) {\r\n        super(paramters);\r\n        this.depth = paramters.depth;\r\n        this.depthLimit = paramters.depthLimit;\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            const { nodes, ...coup } = negamax(board, this.depth, player, this.depthLimit)\r\n            console.log(`Player ${player} (${(this as any).constructor.name}) : ${nodes} nodes`)\r\n            resolve(coup);\r\n        })\r\n    }\r\n}","import { Board, Coup, PlayerValue } from \"./board\";\r\n\r\nexport default function negamax(board: Board, _depth: number, idPlayer: PlayerValue, depthLimit?: number): Coup & {\r\n  nodes: number;\r\n  value: number;\r\n} {\r\n  let coup: Coup = { x: 0, y: 0, orientation: \"horizontal\" };\r\n  let nodes = 0;\r\n\r\n  //key is horizontals stringified + verticals stringified + score stringified + nextPlayer stringified\r\n  //value is the evaluation\r\n  const history = new Map<string, number>();\r\n\r\n  function generateKey(board: Board): string {\r\n    return `${board.horizontals.map(h => h.map(e => e !== -1 ? 1 : 0).join(\"\")).join(\"\")}${board.verticals.map(h => h.map(e => e !== -1 ? 1 : 0).join(\"\")).join(\"\")}${board.score.join(\"\")}${board.tour}`;\r\n  }\r\n\r\n  function _negamax(board: Board, depth: number, maximizingPlayer: boolean): number {\r\n    if (depth === 0 || board.isFinished())\r\n      return board.evaluation(idPlayer) * (maximizingPlayer ? 1 : -1)\r\n\r\n    let value = -Infinity;\r\n\r\n    for (const { board: node, ...coupPlayed } of board.getNodes(depthLimit)) {\r\n      nodes++;\r\n      const key = generateKey(node);\r\n\r\n      if (history.has(key)) {\r\n        value = Math.max(value, history.get(generateKey(node))!);\r\n        continue;\r\n      }\r\n\r\n      const result = _negamax(node, depth - 1, !maximizingPlayer);\r\n\r\n      history.set(key, -result);\r\n\r\n      if (-result > value) {\r\n        if (depth === _depth) coup = coupPlayed\r\n        value = -result;\r\n      }\r\n    }\r\n    return value;\r\n  }\r\n\r\n  const value = _negamax(board, _depth, true)\r\n\r\n  return {\r\n    ...coup,\r\n    value,\r\n    nodes\r\n  };\r\n}","import { Board, Coup, PlayerValue } from \"../board\";\r\nimport { IaPlayer } from \"./IAPlayer\";\r\n\r\n/**\r\n * Classe représentant un joueur IA qui joue de manière aléatoire.\r\n * @extends IaPlayer\r\n */\r\nexport class RandomPlayer extends IaPlayer {\r\n    /**\r\n     * Joue un coup aléatoire sur le plateau.\r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    playIa(board: Board, player: PlayerValue): Promise<Coup> {\r\n        return Promise.resolve(board.getNodes().next().value!)\r\n    }\r\n}\r\n","import { MainToWorkerEventMap } from \"./@types/worker\";\r\nimport { PlayerValue, PlayValue } from \"./utils/board\";\r\nimport Game from \"./utils/game\";\r\nimport { AlphaBetaPlayer } from \"./utils/players/AlphaBetaPlayer\";\r\nimport { FastestPlayer } from \"./utils/players/FastestPlayer\";\r\nimport { HumanPlayer } from \"./utils/players/HumanPlayer\";\r\nimport { MctsPlayer } from \"./utils/players/MCTSPlayer\";\r\nimport { MinimaxPlayer } from \"./utils/players/MinimaxPlayer\";\r\nimport { RandomPlayer } from \"./utils/players/RandomPlayer\";\r\n\r\ndeclare var self: DedicatedWorkerGlobalScope;\r\n\r\nDedicatedWorkerGlobalScope.prototype.emit = function (...data) {\r\n    this.postMessage({ type: data[0], data: data[1] });\r\n}\r\n\r\nself.addEventListener(\"message\", ({ data: { data, type } }) => {\r\n    self.dispatchEvent(new CustomEvent(type, {\r\n        detail: data\r\n    }));\r\n});\r\n\r\nlet game: Game | null = null;\r\n\r\nself.addEventListener(\"start\", ({ detail: { player1, player2, size } }) => {\r\n    if (game) return;\r\n\r\n    const player1Instance = createPlayer(player1);\r\n    const player2Instance = createPlayer(player2);\r\n\r\n    game = new Game(size, player1Instance, player2Instance);\r\n\r\n    if (player1Instance instanceof HumanPlayer) {\r\n        self.addEventListener(\"play\", (e) => {\r\n            player1Instance.dispatchEvent(new CustomEvent(\"play\", {\r\n                detail: e.detail\r\n            }));\r\n        });\r\n    }\r\n\r\n    if (player2Instance instanceof HumanPlayer) {\r\n        self.addEventListener(\"play\", (e) => {\r\n            player2Instance.dispatchEvent(new CustomEvent(\"play\", {\r\n                detail: e.detail\r\n            }));\r\n        });\r\n    }\r\n\r\n    self.emit(\"change\", game.getBoard());\r\n\r\n    game.addEventListener(\"end\", (e) => {\r\n        const { winner } = (\r\n            e as CustomEvent<{\r\n                winner: PlayerValue\r\n            }>\r\n        ).detail;\r\n        self.emit(\"end\", {\r\n            winner\r\n        });\r\n    });\r\n\r\n    game.addEventListener(\"played\", (e) => {\r\n        const { board } = (\r\n            e as CustomEvent<{\r\n                played: {\r\n                    x: number;\r\n                    y: number;\r\n                    orientation: string;\r\n                    player: PlayerValue;\r\n                };\r\n                board: {\r\n                    verticals: ReadonlyArray<ReadonlyArray<PlayValue>>;\r\n                    horizontals: ReadonlyArray<ReadonlyArray<PlayValue>>;\r\n                    cells: ReadonlyArray<ReadonlyArray<PlayValue>>;\r\n                    score: readonly [number, number];\r\n                    tour: PlayerValue;\r\n                };\r\n            }>\r\n        ).detail;\r\n\r\n        self.emit(\"change\", board);\r\n    });\r\n\r\n    game.start().then(() => {\r\n        self.emit(\"end\", {\r\n            winner: game!.getBoard().getWinner()\r\n        });\r\n    });\r\n});\r\n\r\n\r\nfunction createPlayer(player: MainToWorkerEventMap[\"start\"][\"detail\"][\"player1\"]) {\r\n    switch (player.type) {\r\n        case \"human\":\r\n            return new HumanPlayer();\r\n        case \"random\":\r\n            return new RandomPlayer(player);\r\n        case \"minimax\":\r\n            return new MinimaxPlayer(player);\r\n        case \"alphabeta\":\r\n            return new AlphaBetaPlayer(player);\r\n        case \"mcts\":\r\n            return new MctsPlayer(player);\r\n        case \"fastest\":\r\n            return new FastestPlayer(player);\r\n    }\r\n}\r\n\r\n\r\nexport { };\r\n\r\n"],"names":["__webpack_require__","chunkId","obj","prop","Object","prototype","hasOwnProperty","call","b","self","location","Board","constructor","BoardOrSize","cells","verticals","horizontals","previousBoard","score","tour","this","Array","fill","map","getWinner","play","orientation","x","y","newHorizontals","row","newVerticals","newCells","newScore","newTour","console","error","result","check","push","length","forEach","cell","isFinished","_horizontals","evaluation","idPlayer","getNodes","depthLimit","playable","flatMap","value","filter","_ref","_ref2","currentIndex","randomIndex","Math","floor","random","i","board","undefined","node","Game","EventTarget","size","player1","player2","super","players","playing","getBoard","then","coup","newBoard","dispatchEvent","CustomEvent","detail","played","player","winner","start","Player","arguments","totalTime","totalMove","times","IaPlayer","minTimeToPlay","Promise","all","async","performance","now","playIa","end","log","name","resolve","setTimeout","AlphaBetaPlayer","paramters","depth","nodes","_depth","history","Map","generateKey","h","e","join","_nigamax","maximizingPlayer","alpha","beta","Infinity","coupPlayed","key","has","max","get","set","nigamax","FastestPlayer","parameters","ias","workers","ia_1","race","ia","worker","Worker","URL","postMessage","JSON","parse","stringify","type","addEventListener","data","w","terminate","HumanPlayer","once","MctsNode","simulation","c","parent","wins","visits","generator","run","backpropagation","simulate","newChild","expansion","bestNode","selection","bestValue","_orientation","_x","_y","sqrt","done","next","child","mapOrientation","mapX","won","getBestChild","getNumberVisited","MctsPlayer","iteration","lastBoard","lastNode","concat","arr","results","permuteRecursively","subArr","memo","slice","curr","splice","permute","_nodes$get","_nodes$get$get","currentNode","_currentNode","_currentNode$nodes$ge","_currentNode$nodes$ge2","root","bestChild","MinimaxPlayer","_negamax","negamax","RandomPlayer","DedicatedWorkerGlobalScope","emit","game","createPlayer","player1Instance","player2Instance"],"sourceRoot":""}