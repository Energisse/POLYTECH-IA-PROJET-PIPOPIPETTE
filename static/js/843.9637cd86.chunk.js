(()=>{"use strict";class t{constructor(t){this.cells=[],this.verticals=[],this.horizontals=[],this.previousBoard=null,this.score=[0,0],this.tour=0,"number"===typeof t?(this.cells=new Array(t).fill(0).map((()=>new Array(t).fill(-1))),this.verticals=new Array(t).fill(0).map((()=>new Array(t+1).fill(-1))),this.horizontals=new Array(t+1).fill(0).map((()=>new Array(t).fill(-1))),this.score=[0,0],this.tour=0):(this.cells=t.cells,this.verticals=t.verticals,this.horizontals=t.horizontals,this.score=t.score,this.tour=t.tour,this.previousBoard=t.previousBoard||null)}getWinner(){return this.score[0]>this.score[1]?0:this.score[0]<this.score[1]?1:-1}play(i,e,s){const o=this.horizontals.map((t=>[...t])),n=this.verticals.map((t=>[...t])),r=this.cells.map((t=>[...t])),a=[...this.score];let l=this.tour;if("vertical"===i){if(-1!==n[s][e])return console.error("Invalid move "+i+e+s),null;n[s][e]=this.tour}else{if(-1!==o[s][e])return console.error("Invalid move "+i+e+s),null;o[s][e]=this.tour}const h=[];if("horizontal"===i){let t=this.check(o,n,e,s);t&&h.push(t),t=this.check(o,n,e,s-1),t&&h.push(t)}else{let t=this.check(o,n,e,s);t&&h.push(t),t=this.check(o,n,e-1,s),t&&h.push(t)}return h.length?(a[l]+=h.length,h.forEach((t=>{r[t[1]][t[0]]=l}))):l=1===l?0:1,new t({cells:r,verticals:n,horizontals:o,score:a,tour:l,previousBoard:this})}isFinished(){return this.score[0]>this.cells.length**2/2||this.score[1]>this.cells.length**2/2||this.score[0]+this.score[1]===this.cells.length**2}check(t,i,e,s){var o;return!(e<0||e>=this.cells.length||s<0||s>=this.cells.length)&&(-1!==i[s][e]&&-1!==i[s][e+1]&&-1!==t[s][e]&&-1!==(null===(o=t[s+1])||void 0===o?void 0:o[e])&&[e,s])}evaluation(t){return this.score[t]-this.score[1===t?0:1]}*getNodes(t){const i=[...this.verticals.flatMap(((t,i)=>t.map(((t,e)=>({x:e,y:i,value:t,orientation:"vertical"}))))),...this.horizontals.flatMap(((t,i)=>t.map(((t,e)=>({x:e,y:i,value:t,orientation:"horizontal"})))))].filter((t=>{let{value:i}=t;return-1===i}));let e=i.length;for(;0!==e;){let t=Math.floor(Math.random()*e);e--,[i[e],i[t]]=[i[t],i[e]]}for(let s=0;s<i.length;s++){const{x:e,y:o,orientation:n}=i[s],r=this.play(n,e,o);if(r.tour===r.previousBoard.tour&&!r.isFinished()&&(void 0===t||t>0))for(const i of r.getNodes(t?t-1:void 0))yield{...i,x:e,y:o,orientation:n};else yield{x:e,y:o,board:r,orientation:n}}}}class i extends EventTarget{constructor(){super(...arguments),this.totalTime=0,this.totalMove=0,this.times=[]}}class e extends i{constructor(t){let{minTimeToPlay:i}=t;super(),this.minTimeToPlay=0,this.minTimeToPlay=i||500}async play(t,i){return(await Promise.all([new Promise((async e=>{const s=performance.now(),o=await this.playIa(t,i),n=performance.now();this.totalTime+=n-s,this.totalMove++,this.times.push(n-s),console.log(`Player ${i} (${this.constructor.name}) Time: ${n-s}ms Average time: ${this.totalTime/this.totalMove}ms`),e(o)})),new Promise((t=>setTimeout(t,this.minTimeToPlay)))]))[0]}}class s extends e{constructor(t){super(t),this.depth=void 0,this.depthLimit=void 0,this.depth=t.depth,this.depthLimit=t.depthLimit}playIa(t,i){return new Promise((e=>{const{nodes:s,...o}=function(t,i,e,s){let o={x:0,y:0,orientation:"horizontal"},n=0;const r=new Map;function a(t){return`${t.horizontals.map((t=>t.map((t=>-1!==t?1:0)).join(""))).join("")}${t.verticals.map((t=>t.map((t=>-1!==t?1:0)).join(""))).join("")}${t.score.join("")}${t.tour}`}const l=function t(l,h,c){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1/0,d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1/0;if(0===h||l.isFinished())return l.evaluation(e)*(c?1:-1);let p=-1/0;for(const{board:e,...v}of l.getNodes(s)){n++;const s=a(e);if(r.has(s))p=Math.max(p,r.get(a(e)));else{const n=t(e,h-1,!c,-d,-u);r.set(s,-n),-n>p&&(h===i&&(o=v),p=-n)}if(p>=d)return p;u=Math.max(u,p)}return p}(t,i,!0);return{value:l,...o,nodes:n}}(t,this.depth,i,this.depthLimit);console.log(`Player ${i} (${this.constructor.name}) : ${s} nodes`),e(o)}))}}class o{constructor(t,i,e,s){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.wins=void 0,this.visits=void 0,this.nodes=void 0,this.parent=void 0,this.board=void 0,this.player=void 0,this.simulation=void 0,this.c=void 0,this.generator=void 0,this.wins=0,this.visits=0,this.nodes=new Map,this.parent=o,this.generator=t.getNodes(),this.board=t,this.simulation=e,this.player=i,this.c=s}run(){if(this.board.isFinished()){for(let t=0;t<this.simulation;t++)this.backpropagation(this.simulate());return}let t=this.expansion();if(t)for(let i=0;i<this.simulation;i++)t.backpropagation(t.simulate());else{const{bestNode:t}=this.selection();t.run()}}selection(){let t=null,i=0,e=0,s="vertical",o=-1/0;return this.nodes.forEach(((n,r)=>{n.forEach(((n,a)=>{n.forEach(((n,l)=>{const h=n.wins/n.visits+this.c*Math.sqrt(2*Math.log(this.visits)/n.visits);h>o&&(o=h,s=r,i=+a,e=+l,t=n)}))}))})),{bestNode:t,x:i,y:e,orientation:s}}simulate(){let t=this.board;for(;;){const{value:i,done:e}=t.getNodes().next();if(e)break;t=i.board}return t.getWinner()===this.player}expansion(){const{value:t,done:i}=this.generator.next();if(i)return!1;const{orientation:e,x:s,y:n,board:r}=t,a=new o(r,this.player,this.simulation,this.c,this);let l=this.nodes.get(e);l||(l=new Map,this.nodes.set(e,l));let h=l.get(s);return h||(h=new Map,l.set(s,h)),h.set(n,a),a}backpropagation(t){t&&this.wins++,this.visits++,this.parent&&this.parent.backpropagation(t)}getBestChild(){let t=null,i=0,e=0,s="vertical",o=-1/0;return this.nodes.forEach(((n,r)=>{n.forEach(((n,a)=>{n.forEach(((n,l)=>{const h=n.wins/n.visits;h>o&&(s=r,i=+a,e=+l,o=h,t=n)}))}))})),{bestNode:t,x:i,y:e,orientation:s}}getNumberVisited(){return this.visits}}class n extends e{constructor(t){super(t),this.iteration=void 0,this.simulation=void 0,this.c=void 0,this.lastBoard=null,this.lastNode=null,this.iteration=t.iteration,this.simulation=t.simulation,this.c=t.c||Math.sqrt(2)}playIa(t,i){return new Promise((e=>{let s=null;if(this.lastBoard&&this.lastNode){const i=this.lastBoard.horizontals.flatMap(((i,e)=>i.map(((i,s)=>-1===i&&-1!==t.horizontals[e][s]?{x:s,y:e,orientation:"horizontal"}:null)))).filter((t=>t)).concat(this.lastBoard.verticals.flatMap(((i,e)=>i.map(((i,s)=>-1===i&&-1!==t.verticals[e][s]?{x:s,y:e,orientation:"vertical"}:null)))).filter((t=>t)));0===i.length&&(s=this.lastNode);let e=-1/0;if(i.length>0)for(const t of function(t){let i=[];function e(t,s){if(0===t.length)i.push(s.slice());else for(let i=0;i<t.length;i++){let o=t.slice(),n=o.splice(i,1);e(o,s.concat(n))}}return e(t,[]),i}(i)){var n,r;let i=(null===(n=this.lastNode.nodes.get(t[0].orientation))||void 0===n||null===(r=n.get(t[0].x))||void 0===r?void 0:r.get(t[0].y))||null;for(let e=1;e<t.length;e++){var a,l,h;if(i=(null===(a=i)||void 0===a||null===(l=a.nodes.get(t[e].orientation))||void 0===l||null===(h=l.get(t[e].x))||void 0===h?void 0:h.get(t[e].y))||null,!i)break}i&&i.wins>e&&(e=i.wins,s=i)}}let c=s||new o(t,i,this.simulation,this.c);for(;c.getNumberVisited()<this.iteration*this.simulation;)c.run();this.dispatchEvent(new CustomEvent("tree",{detail:c}));let u=c.getBestChild();this.lastNode=u.bestNode,this.lastBoard=t.play(u.orientation,u.x,u.y),e({x:u.x,y:u.y,orientation:u.orientation})}))}}class r extends e{constructor(t){super(t),this.depth=void 0,this.depthLimit=void 0,this.depth=t.depth,this.depthLimit=t.depthLimit}playIa(t,i){return new Promise((e=>{const{nodes:s,...o}=function(t,i,e,s){let o={x:0,y:0,orientation:"horizontal"},n=0;const r=new Map;function a(t){return`${t.horizontals.map((t=>t.map((t=>-1!==t?1:0)).join(""))).join("")}${t.verticals.map((t=>t.map((t=>-1!==t?1:0)).join(""))).join("")}${t.score.join("")}${t.tour}`}const l=function t(l,h,c){if(0===h||l.isFinished())return l.evaluation(e)*(c?1:-1);let u=-1/0;for(const{board:e,...d}of l.getNodes(s)){n++;const s=a(e);if(r.has(s)){u=Math.max(u,r.get(a(e)));continue}const l=t(e,h-1,!c);r.set(s,-l),-l>u&&(h===i&&(o=d),u=-l)}return u}(t,i,!0);return{...o,value:l,nodes:n}}(t,this.depth,i,this.depthLimit);console.log(`Player ${i} (${this.constructor.name}) : ${s} nodes`),e(o)}))}}console.log=()=>{},self.addEventListener("message",(i=>{let e,{data:{board:o,player:a,type:l,parameters:h}}=i;switch(l){case"minimax":e=new r(h);break;case"alphabeta":e=new s(h);break;case"mcts":e=new n(h);break;default:throw new Error("Invalid player type")}e.play(new t(o),a).then(self.postMessage)}))})();
//# sourceMappingURL=843.9637cd86.chunk.js.map