(()=>{"use strict";class t{constructor(t){this.cells=[],this.verticals=[],this.horizontals=[],this.previousBoard=null,this.score=[0,0],this.tour=0,"number"===typeof t?(this.cells=new Array(t).fill(0).map((()=>new Array(t).fill(-1))),this.verticals=new Array(t).fill(0).map((()=>new Array(t+1).fill(-1))),this.horizontals=new Array(t+1).fill(0).map((()=>new Array(t).fill(-1))),this.score=[0,0],this.tour=0):(this.cells=t.cells,this.verticals=t.verticals,this.horizontals=t.horizontals,this.score=t.score,this.tour=t.tour,this.previousBoard=t.previousBoard||null)}getWinner(){return this.score[0]>this.score[1]?0:this.score[0]<this.score[1]?1:-1}play(e,i,s){const o=this.horizontals.map((t=>[...t])),n=this.verticals.map((t=>[...t])),r=this.cells.map((t=>[...t])),l=[...this.score];let a=this.tour;if("vertical"===e){if(-1!==n[s][i])return console.error("Invalid move "+e+i+s),null;n[s][i]=this.tour}else{if(-1!==o[s][i])return console.error("Invalid move "+e+i+s),null;o[s][i]=this.tour}const h=[];if("horizontal"===e){let t=this.check(o,n,i,s);t&&h.push(t),t=this.check(o,n,i,s-1),t&&h.push(t)}else{let t=this.check(o,n,i,s);t&&h.push(t),t=this.check(o,n,i-1,s),t&&h.push(t)}return h.length?(l[a]+=h.length,h.forEach((t=>{r[t[1]][t[0]]=a}))):a=1===a?0:1,new t({cells:r,verticals:n,horizontals:o,score:l,tour:a,previousBoard:this})}isFinished(){return this.score[0]>this.cells.length**2/2||this.score[1]>this.cells.length**2/2||this.score[0]+this.score[1]===this.cells.length**2}check(t,e,i,s){var o;return!(i<0||i>=this.cells.length||s<0||s>=this.cells.length)&&(-1!==e[s][i]&&-1!==e[s][i+1]&&-1!==t[s][i]&&-1!==(null===(o=t[s+1])||void 0===o?void 0:o[i])&&[i,s])}evaluation(t){return this.score[t]-this.score[1===t?0:1]}*getNodes(t){const e=[...this.verticals.flatMap(((t,e)=>t.map(((t,i)=>({x:i,y:e,value:t,orientation:"vertical"}))))).filter((t=>{let{value:e}=t;return-1===e})),...this.horizontals.flatMap(((t,e)=>t.map(((t,i)=>({x:i,y:e,value:t,orientation:"horizontal"}))))).filter((t=>{let{value:e}=t;return-1===e}))];let i=e.length;for(;0!==i;){let t=Math.floor(Math.random()*i);i--,[e[i],e[t]]=[e[t],e[i]]}for(let s=0;s<e.length;s++){const{x:i,y:o,orientation:n}=e[s],r=this.play(n,i,o);if(r.tour===r.previousBoard.tour&&!r.isFinished()&&(void 0===t||t>0))for(const e of r.getNodes(t?t-1:void 0))yield{...e,x:i,y:o,orientation:n};else yield{x:i,y:o,board:r,orientation:n}}}}class e extends EventTarget{constructor(){super(...arguments),this.totalTime=0,this.totalMove=0,this.times=[]}}class i extends e{constructor(t){let{minTimeToPlay:e}=t;super(),this.minTimeToPlay=0,this.minTimeToPlay=e||500}async play(t,e){return(await Promise.all([new Promise((async i=>{const s=performance.now(),o=await this.playIa(t,e),n=performance.now();this.totalTime+=n-s,this.totalMove++,this.times.push(n-s),console.log(`Player ${e} (${this.constructor.name}) Time: ${n-s}ms Average time: ${this.totalTime/this.totalMove}ms`),i(o)})),new Promise((t=>setTimeout(t,this.minTimeToPlay)))]))[0]}}class s extends i{constructor(t){super(t),this.depth=void 0,this.depthLimit=void 0,this.depth=t.depth,this.depthLimit=t.depthLimit}playIa(t,e){return new Promise((i=>{const{nodes:s,...o}=function(t,e,i,s,o){let n=0,r=0,l="vertical",a=0;const h=function t(i,h,c){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1/0,d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1/0;if(0===h||i.isFinished())return i.evaluation(s)*(c?1:-1);let p=-1/0;for(const{board:s,x:v,y:m,orientation:f}of i.getNodes(o)){a++;const i=t(s,h-1,!c,-d,-u);if(-i>p&&(p=-i,h===e&&(n=v,r=m,l=f)),p>=d)return p;u=Math.max(u,p)}return p}(t,e,i);return{value:h,x:n,y:r,orientation:l,nodes:a}}(t,this.depth,!0,e,this.depthLimit);console.log(`Player ${e} (${this.constructor.name}) : ${s} nodes`),i(o)}))}}class o{constructor(t,e,i,s){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.wins=void 0,this.visits=void 0,this.nodes=void 0,this.parent=void 0,this.board=void 0,this.player=void 0,this.simulation=void 0,this.c=void 0,this.generator=void 0,this.wins=0,this.visits=0,this.nodes=new Map,this.parent=o,this.generator=t.getNodes(),this.board=t,this.simulation=i,this.player=e,this.c=s}run(){if(this.board.isFinished()){for(let t=0;t<this.simulation;t++)this.backpropagation(this.simulate());return}let t=this.expansion();if(t)for(let e=0;e<this.simulation;e++)t.backpropagation(t.simulate());else{const{bestNode:t}=this.selection();t.run()}}selection(){let t=null,e=0,i=0,s="vertical",o=-1/0;return this.nodes.forEach(((n,r)=>{n.forEach(((n,l)=>{n.forEach(((n,a)=>{const h=n.wins/n.visits+this.c*Math.sqrt(2*Math.log(this.visits)/n.visits);h>o&&(o=h,s=r,e=+l,i=+a,t=n)}))}))})),{bestNode:t,x:e,y:i,orientation:s}}simulate(){let t=this.board;for(;;){const{value:e,done:i}=t.getNodes().next();if(i)break;t=e.board}return t.getWinner()===this.player}expansion(){const{value:t,done:e}=this.generator.next();if(e)return!1;const{orientation:i,x:s,y:n,board:r}=t,l=new o(r,this.player,this.simulation,this.c,this);let a=this.nodes.get(i);a||(a=new Map,this.nodes.set(i,a));let h=a.get(s);return h||(h=new Map,a.set(s,h)),h.set(n,l),l}backpropagation(t){t&&this.wins++,this.visits++,this.parent&&this.parent.backpropagation(t)}getBestChild(){let t=null,e=0,i=0,s="vertical",o=-1/0;return this.nodes.forEach(((n,r)=>{n.forEach(((n,l)=>{n.forEach(((n,a)=>{const h=n.wins/n.visits;h>o&&(s=r,e=+l,i=+a,o=h,t=n)}))}))})),{bestNode:t,x:e,y:i,orientation:s}}getNumberVisited(){return this.visits}}class n extends i{constructor(t){super(t),this.iteration=void 0,this.simulation=void 0,this.c=void 0,this.lastBoard=null,this.lastNode=null,this.iteration=t.iteration,this.simulation=t.simulation,this.c=t.c||Math.sqrt(2)}playIa(t,e){return new Promise((i=>{let s=null;if(this.lastBoard&&this.lastNode){const e=this.lastBoard.horizontals.flatMap(((e,i)=>e.map(((e,s)=>-1===e&&-1!==t.horizontals[i][s]?{x:s,y:i,orientation:"horizontal"}:null)))).filter((t=>t)).concat(this.lastBoard.verticals.flatMap(((e,i)=>e.map(((e,s)=>-1===e&&-1!==t.verticals[i][s]?{x:s,y:i,orientation:"vertical"}:null)))).filter((t=>t)));0===e.length&&(s=this.lastNode);let i=-1/0;if(e.length>0)for(const t of function(t){let e=[];function i(t,s){if(0===t.length)e.push(s.slice());else for(let e=0;e<t.length;e++){let o=t.slice(),n=o.splice(e,1);i(o,s.concat(n))}}return i(t,[]),e}(e)){var n,r;let e=(null===(n=this.lastNode.nodes.get(t[0].orientation))||void 0===n||null===(r=n.get(t[0].x))||void 0===r?void 0:r.get(t[0].y))||null;for(let i=1;i<t.length;i++){var l,a,h;if(e=(null===(l=e)||void 0===l||null===(a=l.nodes.get(t[i].orientation))||void 0===a||null===(h=a.get(t[i].x))||void 0===h?void 0:h.get(t[i].y))||null,!e)break}e&&e.wins>i&&(i=e.wins,s=e)}}let c=s||new o(t,e,this.simulation,this.c);for(;c.getNumberVisited()<this.iteration*this.simulation;)c.run();this.dispatchEvent(new CustomEvent("tree",{detail:c}));let u=c.getBestChild();this.lastNode=u.bestNode,this.lastBoard=t.play(u.orientation,u.x,u.y),i({x:u.x,y:u.y,orientation:u.orientation})}))}}class r extends i{constructor(t){super(t),this.depth=void 0,this.depthLimit=void 0,this.depth=t.depth,this.depthLimit=t.depthLimit}playIa(t,e){return new Promise((i=>{const{nodes:s,...o}=function(t,e,i,s,o){let n=0,r=0,l="vertical",a=0;const h=function t(i,h,c){if(0===h||i.isFinished())return i.evaluation(s)*(c?1:-1);let u=-1/0;for(const{board:s,x:d,y:p,orientation:v}of i.getNodes(o)){a++;const i=t(s,h-1,!c);-i>u&&(h===e&&(n=d,r=p,l=v),u=-i)}return u}(t,e,i);return{x:n,y:r,orientation:l,value:h,nodes:a}}(t,this.depth,!0,e,this.depthLimit);console.log(`Player ${e} (${this.constructor.name}) : ${s} nodes`),i(o)}))}}console.log=()=>{},self.addEventListener("message",(e=>{let i,{data:{board:o,player:l,type:a,parameters:h}}=e;switch(a){case"minimax":i=new r(h);break;case"alphabeta":i=new s(h);break;case"mcts":i=new n(h);break;default:throw new Error("Invalid player type")}i.play(new t(o),l).then(self.postMessage)}))})();
//# sourceMappingURL=843.ce75cdb2.chunk.js.map