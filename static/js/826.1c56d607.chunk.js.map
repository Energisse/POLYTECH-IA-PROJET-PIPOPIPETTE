{"version":3,"file":"static/js/826.1c56d607.chunk.js","mappings":"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","sources":["../webpack/bootstrap","../webpack/runtime/get javascript chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","utils/game.ts","utils/mcts.ts","utils/negamax.ts","utils/nigamax.ts","utils/player.ts","worker.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"dd4c2374\" + \".chunk.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/POLYTECH-IA-PROJET-PIPOPIPETTE/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t826: 1\n};\n\n// no chunk install function needed\n// no chunk loading\n\n// no HMR\n\n// no HMR manifest","import { Player } from \"./player\";\r\n\r\nexport default class Game extends EventTarget {\r\n  readonly board: Board;\r\n  private players: [Player, Player];\r\n\r\n  constructor(size: number, player1: Player, player2: Player) {\r\n    super();\r\n    this.board = new Board(size);\r\n    this.players = [player1, player2];\r\n    this.play();\r\n  }\r\n\r\n  public async play() {\r\n    await this.players[this.board.getTour()].play(this.board, this.board.getTour()).then((coup) => {\r\n      this.board.play(coup.orientation, coup.x, coup.y);\r\n      if (!this.board.isFinished()) this.play();\r\n    });\r\n  }\r\n}\r\n\r\nexport type playValue = -1 | 0 | 1;\r\nexport type playerValue = 0 | 1;\r\n\r\nexport class Board extends EventTarget {\r\n  private cells: playValue[][] = [];\r\n  private verticals: playValue[][] = [];\r\n  private horizontals: playValue[][] = [];\r\n\r\n  private score: [number, number] = [0, 0];\r\n\r\n  private tour: playerValue = 0;\r\n\r\n  constructor(size: number);\r\n  constructor(board: { cells: playValue[][]; verticals: playValue[][]; horizontals: playValue[][]; score: [number, number]; tour: playerValue });\r\n  constructor(BoardOrSize: number | { cells: playValue[][]; verticals: playValue[][]; horizontals: playValue[][]; score: [number, number]; tour: playerValue }) {\r\n    super();\r\n    if (typeof BoardOrSize === \"number\") {\r\n      this.cells = new Array(BoardOrSize).fill(0).map(() => new Array(BoardOrSize).fill(-1));\r\n      this.verticals = new Array(BoardOrSize)\r\n        .fill(0)\r\n        .map(() => new Array(BoardOrSize + 1).fill(-1));\r\n      this.horizontals = new Array(BoardOrSize + 1)\r\n        .fill(0)\r\n        .map(() => new Array(BoardOrSize).fill(-1));\r\n      this.score = [0, 0];\r\n      this.tour = 0;\r\n    } else {\r\n      this.cells = BoardOrSize.cells;\r\n      this.verticals = BoardOrSize.verticals;\r\n      this.horizontals = BoardOrSize.horizontals;\r\n      this.score = BoardOrSize.score;\r\n      this.tour = BoardOrSize.tour;\r\n    }\r\n  }\r\n\r\n  public getCells(): playValue[][] {\r\n    return this.cells;\r\n  }\r\n\r\n  public getVerticals(): playValue[][] {\r\n    return this.verticals;\r\n  }\r\n\r\n  public getHorizontals(): playValue[][] {\r\n    return this.horizontals;\r\n  }\r\n\r\n  public getScore(): [number, number] {\r\n    return this.score;\r\n  }\r\n\r\n  public getTour(): playerValue {\r\n    return this.tour;\r\n  }\r\n\r\n  public play(\r\n    orientation: \"vertical\" | \"horizontal\",\r\n    x: number,\r\n    y: number\r\n  ): void {\r\n    if (orientation === \"vertical\") {\r\n      if (this.verticals[y][x] !== -1) return;\r\n      this.verticals[y][x] = this.tour;\r\n    } else {\r\n      if (this.horizontals[y][x] !== -1) return;\r\n      this.horizontals[y][x] = this.tour;\r\n    }\r\n\r\n    const cells: Array<[x: number, y: number]> = [];\r\n\r\n    if (orientation === \"horizontal\") {\r\n      let result = this.check(x, y);\r\n      if (result) cells.push(result);\r\n      result = this.check(x, y - 1);\r\n      if (result) cells.push(result);\r\n    } else {\r\n      let result = this.check(x, y);\r\n      if (result) cells.push(result);\r\n      result = this.check(x - 1, y);\r\n      if (result) cells.push(result);\r\n    }\r\n\r\n    if (!cells.length) {\r\n      this.tour = this.tour === 1 ? 0 : 1;\r\n    } else {\r\n      this.score[this.tour] += cells.length;\r\n\r\n      cells.forEach((cell) => {\r\n        this.cells[cell[1]][cell[0]] = this.tour;\r\n      });\r\n    }\r\n\r\n    this.dispatchEvent(\r\n      new CustomEvent(\"boardChange\", {\r\n        detail: {\r\n          verticals: this.verticals,\r\n          horizontals: this.horizontals,\r\n          cells: this.cells,\r\n          score: this.score,\r\n        },\r\n      })\r\n    );\r\n\r\n\r\n    if (this.isFinished()) {\r\n      const winner = this.score[0] === this.score[1] ? 0 : this.score[0] > this.score[1] ? 0 : 1;\r\n      this.dispatchEvent(new CustomEvent(\"end\", { detail: { winner } }));\r\n    }\r\n  }\r\n\r\n  public isFinished() {\r\n    return this.score[0] > this.cells.length ** 2 / 2 || this.score[1] > this.cells.length ** 2 / 2 || this.score[0] + this.score[1] === this.cells.length ** 2;\r\n  }\r\n\r\n  private check(x: number, y: number): false | [x: number, y: number] {\r\n    if (x < 0 || x >= this.cells.length || y < 0 || y >= this.cells.length) {\r\n      return false;\r\n    }\r\n    if (\r\n      this.verticals[y][x] !== -1 &&\r\n      this.verticals[y][x + 1] !== -1 &&\r\n      this.horizontals[y][x] !== -1 &&\r\n      this.horizontals[y + 1]?.[x] !== -1\r\n    ) {\r\n      return [x, y];\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public evaluation(idPlayer: number) {\r\n    return this.score[idPlayer] - this.score[idPlayer === 1 ? 0 : 1];\r\n  }\r\n\r\n  public copy() {\r\n    const board = new Board(this.cells.length);\r\n    board.cells = this.cells.map((row) => [...row]);\r\n    board.verticals = this.verticals.map((row) => [...row]);\r\n    board.horizontals = this.horizontals.map((row) => [...row]);\r\n    board.score = [...this.score];\r\n    board.tour = this.tour;\r\n    return board;\r\n  }\r\n\r\n  private *getNodesVertical(): Generator<\r\n    {\r\n      x: number;\r\n      y: number;\r\n      board: Board;\r\n      orientation: \"vertical\" | \"horizontal\";\r\n    },\r\n    void,\r\n    void\r\n  > {\r\n    const playable = this.verticals\r\n      .flatMap((row, y) => row.map((value, x) => ({ x, y, value })))\r\n      .filter(({ value }) => value === -1);\r\n\r\n    while (playable.length > 0) {\r\n      const { x, y } = playable.splice(\r\n        Math.floor(Math.random() * playable.length),\r\n        1\r\n      )[0];\r\n      const board = this.copy();\r\n      const lastTour = board.tour;\r\n      board.play(\"vertical\", x, y);\r\n      if (board.tour === lastTour && !board.isFinished()) {\r\n        for (const node of board.getNodes()) {\r\n          yield { ...node, x, y, orientation: \"vertical\" };\r\n        }\r\n      } else yield { x, y, board, orientation: \"vertical\" };\r\n    }\r\n  }\r\n\r\n  private *getNodesHorizontal(): Generator<\r\n    {\r\n      x: number;\r\n      y: number;\r\n      board: Board;\r\n      orientation: \"vertical\" | \"horizontal\";\r\n    },\r\n    void,\r\n    void\r\n  > {\r\n    const playable = this.horizontals\r\n      .flatMap((row, y) => row.map((value, x) => ({ x, y, value })))\r\n      .filter(({ value }) => value === -1);\r\n\r\n    while (playable.length > 0) {\r\n      const { x, y } = playable.splice(\r\n        Math.floor(Math.random() * playable.length),\r\n        1\r\n      )[0];\r\n      const board = this.copy();\r\n      const lastTour = board.tour;\r\n      board.play(\"horizontal\", x, y);\r\n      if (board.tour === lastTour && !board.isFinished()) {\r\n        for (const node of board.getNodes()) {\r\n          yield { ...node, x, y, orientation: \"horizontal\" };\r\n        }\r\n      } else yield { x, y, board, orientation: \"horizontal\" };\r\n    }\r\n  }\r\n\r\n  public *getNodes(): Generator<\r\n    {\r\n      x: number;\r\n      y: number;\r\n      board: Board;\r\n      orientation: \"vertical\" | \"horizontal\";\r\n    },\r\n    void,\r\n    void\r\n  > {\r\n    const verticals = this.getNodesVertical();\r\n    const horizontals = this.getNodesHorizontal();\r\n\r\n    let doneHorizontal = false;\r\n    let doneVertical = false;\r\n\r\n    while (!doneHorizontal && !doneVertical) {\r\n      if (Math.random() < 0.5) {\r\n        const { value, done } = verticals.next();\r\n        if (done) doneVertical = true;\r\n        else yield value;\r\n      } else {\r\n        const { value, done } = horizontals.next();\r\n        if (done) doneHorizontal = true;\r\n        else yield value;\r\n      }\r\n    }\r\n\r\n    if (!doneHorizontal) {\r\n      for (const value of horizontals) {\r\n        yield value;\r\n      }\r\n    }\r\n\r\n    if (!doneVertical) {\r\n      for (const value of verticals) {\r\n        yield value;\r\n      }\r\n    }\r\n  }\r\n\r\n  // public *getNodes(): Generator<{\r\n  //   x: number;\r\n  //   y: number;\r\n  //   board: Board;\r\n  //   orientation: \"vertical\" | \"horizontal\";\r\n  // }, void, void> {\r\n  //   for (let y = 0; y < this.verticals.length; y++) {\r\n  //     for (let x = 0; x < this.verticals[y].length; x++) {\r\n  //       if (this.verticals[y][x] === 0) {\r\n  //         const board = this.copy();\r\n  //         const lastTour = board.tour;\r\n  //         board.play(\"vertical\", x, y);\r\n  //         if (board.tour === lastTour && !board.isFinished()) {\r\n  //           for (const node of board.getNodes()) {\r\n  //             yield { ...node, x, y, orientation: \"vertical\" };\r\n  //           }\r\n  //         }\r\n  //         else yield { x, y, board, orientation: \"vertical\" };\r\n  //       }\r\n  //     }\r\n  //   }\r\n\r\n  //   for (let y = 0; y < this.horizontals.length; y++) {\r\n  //     for (let x = 0; x < this.horizontals[y].length; x++) {\r\n  //       if (this.horizontals[y][x] === 0) {\r\n  //         const board = this.copy();\r\n  //         const lastTour = board.tour;\r\n  //         board.play(\"horizontal\", x, y);\r\n  //         if (board.tour === lastTour && !board.isFinished()) {\r\n  //           for (const node of board.getNodes()) {\r\n  //             yield { ...node, x, y, orientation: \"horizontal\" };\r\n  //           }\r\n  //         }\r\n  //         else yield { x, y, board, orientation: \"horizontal\" };\r\n  //       }\r\n  //     }\r\n  //   }\r\n  // }\r\n}\r\n\r\n\r\n","import { Board } from \"./game\";\r\n\r\n\r\nexport class MctsNode {\r\n    public wins: number;\r\n    public visits: number;\r\n    private nodes: Map<\"vertical\" | \"horizontal\", Map<number, Map<number, MctsNode>>>;\r\n    public parent: MctsNode | null;\r\n    private board: Board;\r\n    private player: 0 | 1;\r\n    private simulation: number;\r\n    private c: number\r\n    private generator: Generator<{ orientation: \"vertical\" | \"horizontal\"; x: number; y: number, board: Board }, void, unknown>;\r\n\r\n    constructor(board: Board, player: 0 | 1, simulation: number, c: number, parent: MctsNode | null = null) {\r\n        this.wins = 0;\r\n        this.visits = 0;\r\n        this.nodes = new Map();\r\n        this.parent = parent;\r\n        this.generator = board.getNodes();\r\n        this.board = board;\r\n        this.simulation = simulation;\r\n        this.player = player;\r\n        this.c = c;\r\n    }\r\n\r\n\r\n    public run() {\r\n        if (this.board.isFinished()) {\r\n            for (let i = 0; i < this.simulation; i++) {\r\n                this.backpropagation(this.simulate());\r\n            }\r\n            return\r\n        }\r\n\r\n        let newChild = this.expansion()\r\n        if (newChild) {\r\n            for (let i = 0; i < this.simulation; i++) {\r\n                newChild.backpropagation(newChild.simulate());\r\n            }\r\n        }\r\n        else {\r\n            const { bestNode } = this.selection();\r\n            bestNode.run();\r\n        }\r\n    }\r\n\r\n    private selection(): {\r\n        bestNode: MctsNode;\r\n        x: number;\r\n        y: number;\r\n        orientation: \"vertical\" | \"horizontal\";\r\n    } {\r\n        let bestNode: MctsNode | null = null;\r\n        let x: number = 0;\r\n        let y: number = 0;\r\n        let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n        let bestValue = -Infinity;\r\n        this.nodes.forEach((row, _orientation) => {\r\n            row.forEach((cell, _x) => {\r\n                cell.forEach((node, _y) => {\r\n                    const value = node.wins / node.visits + this.c * Math.sqrt(2 * Math.log(this.visits) / node.visits);\r\n                    if (value > bestValue) {\r\n                        bestValue = value;\r\n                        orientation = _orientation as \"vertical\" | \"horizontal\";\r\n                        x = +_x;\r\n                        y = +_y;\r\n                        bestNode = node;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return { bestNode: bestNode!, x, y, orientation };\r\n    }\r\n\r\n    private simulate() {\r\n        let result = this.board.getNodes().next()\r\n        let endBoard;\r\n        while (!result.done) {\r\n            endBoard = result.value.board;\r\n            result = result.value.board.getNodes().next();\r\n        }\r\n        if (!endBoard) return false;\r\n        return endBoard.getScore()[this.player] > endBoard.getScore()[this.player === 1 ? 0 : 1];\r\n    }\r\n\r\n    private expansion() {\r\n        const { value, done } = this.generator.next();\r\n\r\n        if (done) return false;\r\n\r\n        const { orientation, x, y, board } = value;\r\n        const child = new MctsNode(board, this.player, this.simulation, this.c, this);\r\n        let mapOrientation = this.nodes.get(orientation);\r\n        if (!mapOrientation) {\r\n            mapOrientation = new Map();\r\n            this.nodes.set(orientation, mapOrientation);\r\n        }\r\n\r\n        let mapX = mapOrientation.get(x);\r\n        if (!mapX) {\r\n            mapX = new Map();\r\n            mapOrientation.set(x, mapX);\r\n        }\r\n\r\n        mapX.set(y, child);\r\n\r\n        return child;\r\n    }\r\n\r\n    private backpropagation(won: boolean) {\r\n        if (won) {\r\n            this.wins++;\r\n        }\r\n        this.visits++;\r\n        if (this.parent) {\r\n            this.parent.backpropagation(won);\r\n        }\r\n    }\r\n\r\n    public getBestChild() {\r\n        let bestNode: MctsNode | null = null;\r\n        let x: number = 0;\r\n        let y: number = 0;\r\n        let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n        let bestValue = -Infinity;\r\n        this.nodes.forEach((row, _orientation) => {\r\n            row.forEach((cell, _x) => {\r\n                cell.forEach((node, _y) => {\r\n                    const value = node.wins / node.visits;\r\n                    if (value > bestValue) {\r\n                        orientation = _orientation as \"vertical\" | \"horizontal\";\r\n                        x = +_x;\r\n                        y = +_y;\r\n                        bestValue = value;\r\n                        bestNode = node;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return { bestNode: bestNode!, x, y, orientation };\r\n    }\r\n\r\n    getNumberVisited() {\r\n        return this.visits;\r\n    }\r\n\r\n}","import { Board } from \"./game\";\r\n\r\nexport default function negamax(\r\n  board: Board,\r\n  depth: number,\r\n  maximizingPlayer: boolean,\r\n  idPlayer: number\r\n): {\r\n  x: number;\r\n  y: number;\r\n  value: number;\r\n  orientation: \"vertical\" | \"horizontal\";\r\n} {\r\n  if (depth === 0 || board.isFinished())\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      orientation: \"vertical\",\r\n      value: board.evaluation(idPlayer) * (maximizingPlayer ? 1 : -1),\r\n    };\r\n  let value = -Infinity;\r\n  let x = -1,\r\n    y = -1;\r\n  let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n  for (const {\r\n    board: node,\r\n    x: _x,\r\n    y: _y,\r\n    orientation: _orientation,\r\n  } of board.getNodes()) {\r\n    const { value: result } = negamax(node, depth - 1, !maximizingPlayer, idPlayer);\r\n    if (-result > value) {\r\n      value = -result;\r\n      x = _x;\r\n      y = _y;\r\n      orientation = _orientation;\r\n    }\r\n  }\r\n  return { x, y, value, orientation };\r\n}","import { Board } from \"./game\";\r\n\r\nexport default function nigamax(\r\n  board: Board,\r\n  depth: number,\r\n  maximizingPlayer: boolean,\r\n  idPlayer: number,\r\n  alpha: number = -Infinity,\r\n  beta: number = Infinity\r\n): {\r\n  x: number;\r\n  y: number;\r\n  value: number;\r\n  orientation: \"vertical\" | \"horizontal\";\r\n} {\r\n  if (depth === 0 || board.isFinished()) {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      orientation: \"vertical\",\r\n      value: board.evaluation(idPlayer) * (maximizingPlayer ? 1 : -1),\r\n    };\r\n  }\r\n  let value = -Infinity;\r\n  let x = -1,\r\n    y = -1;\r\n  let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n  for (const {\r\n    board: node,\r\n    x: _x,\r\n    y: _y,\r\n    orientation: _orientation,\r\n  } of board.getNodes()) {\r\n    const { value: result } = nigamax(\r\n      node,\r\n      depth - 1,\r\n      !maximizingPlayer,\r\n      idPlayer,\r\n      -beta,\r\n      -alpha\r\n    );\r\n    if (-result > value) {\r\n      value = -result;\r\n      x = _x;\r\n      y = _y;\r\n      orientation = _orientation;\r\n    }\r\n    if (value >= beta) {\r\n      return {\r\n        x,\r\n        y,\r\n        orientation,\r\n        value,\r\n      };\r\n    }\r\n    alpha = Math.max(alpha, value);\r\n  }\r\n  return { x, y, orientation, value };\r\n}\r\n","import { Board } from \"./game\";\r\nimport { MctsNode } from \"./mcts\";\r\nimport negamax from \"./negamax\";\r\nimport nigamax from \"./nigamax\";\r\n\r\ninterface Coup {\r\n    x: number,\r\n    y: number,\r\n    orientation: \"vertical\" | \"horizontal\"\r\n}\r\n\r\nexport abstract class Player extends EventTarget {\r\n    protected totalTime: number = 0;\r\n    protected totalMove: number = 0;\r\n    protected times: number[] = [];\r\n\r\n    abstract play(board: Board, player: 0 | 1): Promise<Coup>\r\n}\r\n\r\nexport class HumanPlayer extends Player {\r\n    play(board: Board, player: 0 | 1) {\r\n        return new Promise<Coup>((resolve) => {\r\n            const start = performance.now()\r\n            this.addEventListener(\"play\", (e: Event) => {\r\n                const end = performance.now()\r\n                this.totalTime += end - start\r\n                this.totalMove++\r\n                this.times.push(end - start)\r\n                console.log(`Player ${player} (${(this as any).constructor.name}) Time: ${end - start} Average time: ${this.totalTime / this.totalMove}ms`)\r\n                console.table(this.times)\r\n                const customEvent = e as CustomEvent<{ x: number, y: number, orientation: \"vertical\" | \"horizontal\" }>;\r\n                resolve(customEvent.detail);\r\n            }, { once: true })\r\n        })\r\n    }\r\n}\r\n\r\nexport abstract class iaPlayer extends Player {\r\n    async play(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return (await Promise.all([\r\n            (async (): Promise<Coup> => {\r\n                const start = performance.now()\r\n                const result = await this.playIa(board, player)\r\n                const end = performance.now()\r\n                this.totalTime += end - start\r\n                this.totalMove++\r\n                this.times.push(end - start)\r\n                console.log(`Player ${player} (${(this as any).constructor.name}) Time: ${end - start} Average time: ${this.totalTime / this.totalMove}ms`)\r\n                console.table(this.times)\r\n                return result\r\n            })(),\r\n            //delay to see the move\r\n            new Promise<void>((resolve) => {\r\n                setTimeout(() => {\r\n                    resolve()\r\n                }, 500)\r\n            })\r\n        ]))[0]\r\n    }\r\n\r\n    abstract playIa(board: Board, player: number): Promise<Coup>;\r\n}\r\n\r\nexport class MctsPlayer extends iaPlayer {\r\n    private iteration: number;\r\n    private simulation: number;\r\n    private c: number\r\n\r\n    constructor({ iteration, simulation, c }: { iteration: number, simulation: number, c?: number }) {\r\n        super();\r\n        this.iteration = iteration;\r\n        this.simulation = simulation;\r\n        this.c = c || Math.sqrt(2);\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            let root = new MctsNode(board, player, this.simulation, this.c);\r\n            while (root.getNumberVisited() < this.iteration * this.simulation) {\r\n                root.run();\r\n            }\r\n            this.dispatchEvent(new CustomEvent(\"tree\", { detail: root }));\r\n            let bestChild = root.getBestChild();\r\n            resolve({ x: bestChild.x, y: bestChild.y, orientation: bestChild.orientation });\r\n        })\r\n    }\r\n}\r\n\r\nexport class RandomPlayer extends iaPlayer {\r\n    playIa(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            const { orientation, x, y } = board.getNodes().next().value!\r\n            resolve({ x, y, orientation });\r\n        })\r\n    }\r\n\r\n}\r\n\r\nexport class MinimaxPlayer extends iaPlayer {\r\n    private depth: number;\r\n\r\n    constructor({ depth }: { depth: number }) {\r\n        super();\r\n        this.depth = depth;\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            resolve(negamax(board, this.depth, true, player));\r\n        })\r\n    }\r\n}\r\n\r\nexport class FastestPlayer extends iaPlayer {\r\n    private depth: number;\r\n    private ias: (\"minimax\" | \"alphabeta\" | \"mcts\")[] = [\"minimax\", \"alphabeta\", \"mcts\"]\r\n\r\n    constructor({ depth }: { depth: number }) {\r\n        super();\r\n        this.depth = depth;\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1) {\r\n        const workers: Worker[] = []\r\n\r\n        return Promise.race(this.ias.map(ia => {\r\n            return new Promise<[Coup, typeof ia]>((resolve) => {\r\n                const worker = new Worker(new URL(\"../playerWorker.ts\", import.meta.url));\r\n                workers.push(worker)\r\n                worker.postMessage({ board: JSON.parse(JSON.stringify(board)), depth: this.depth, player, type: ia });\r\n                worker.addEventListener(\"message\", (e) => {\r\n                    resolve([e.data, ia]);\r\n                })\r\n            })\r\n        })).then(([coup, ia]) => {\r\n            workers.forEach(worker => worker.terminate())\r\n            console.log(ia)\r\n            return coup\r\n        })\r\n\r\n    }\r\n}\r\n\r\n\r\nexport class AlphaBetaPlayer extends iaPlayer {\r\n    private depth: number;\r\n\r\n    constructor({ depth }: { depth: number }) {\r\n        super();\r\n        this.depth = depth;\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1) {\r\n        return new Promise<Coup>((resolve) => {\r\n            resolve(nigamax(board, this.depth, true, player));\r\n        })\r\n    }\r\n}\r\n","import { MainToWorkerEventMap } from \"./@types/worker\";\r\nimport Game, { playValue, playerValue } from \"./utils/game\";\r\nimport { AlphaBetaPlayer, FastestPlayer, HumanPlayer, MctsPlayer, MinimaxPlayer, RandomPlayer } from \"./utils/player\";\r\n\r\ndeclare var self: DedicatedWorkerGlobalScope;\r\n\r\nDedicatedWorkerGlobalScope.prototype.emit = function (...data) {\r\n    this.postMessage({ type: data[0], data: data[1] });\r\n}\r\n\r\nself.addEventListener(\"message\", ({ data: { data, type } }) => {\r\n    self.dispatchEvent(new CustomEvent(type, {\r\n        detail: data\r\n    }));\r\n});\r\n\r\nlet game: Game | null = null;\r\n\r\ntype Node = {\r\n    visits: number,\r\n    wins: number,\r\n    nodes: Map<string, Map<number, Map<number, Node>>>\r\n}\r\n\r\ntype Data = {\r\n    name: string,\r\n    children: Data[]\r\n}\r\n\r\nfunction formatNode(node: Node): Data {\r\n    const children = new Array<Data>();\r\n    node.nodes.forEach((row, orientation) => {\r\n        row.forEach((cell, x) => {\r\n            cell.forEach((node, y) => {\r\n                children.push(formatNode(node));\r\n            });\r\n        });\r\n    });\r\n\r\n    return {\r\n        name: `${node.wins}/${node.visits}`,\r\n        children\r\n    }\r\n\r\n}\r\n\r\nself.addEventListener(\"start\", ({ detail: { player1, player2, size } }) => {\r\n    if (game) return;\r\n\r\n    const player1Instance = createPlayer(player1);\r\n    const player2Instance = createPlayer(player2);\r\n\r\n    player1Instance.addEventListener(\"tree\", (e) => {\r\n        self.emit(\"tree\", {\r\n            player: 1,\r\n            tree: formatNode((e as CustomEvent<Node>).detail)\r\n        });\r\n    });\r\n\r\n    player2Instance.addEventListener(\"tree\", (e) => {\r\n        self.emit(\"tree\", {\r\n            player: 2,\r\n            tree: formatNode((e as CustomEvent<Node>).detail)\r\n        });\r\n    });\r\n\r\n\r\n    game = new Game(size, player1Instance, player2Instance);\r\n\r\n    if (player1Instance instanceof HumanPlayer) {\r\n        self.addEventListener(\"play\", (e) => {\r\n            player1Instance.dispatchEvent(new CustomEvent(\"play\", {\r\n                detail: e.detail\r\n            }));\r\n        });\r\n    }\r\n\r\n    if (player2Instance instanceof HumanPlayer) {\r\n        self.addEventListener(\"play\", (e) => {\r\n            player2Instance.dispatchEvent(new CustomEvent(\"play\", {\r\n                detail: e.detail\r\n            }));\r\n        });\r\n    }\r\n\r\n    self.emit(\"change\", {\r\n        verticals: game.board.getVerticals(),\r\n        horizontals: game.board.getHorizontals(),\r\n        score: game.board.getScore(),\r\n        tour: game.board.getTour(),\r\n        cells: game.board.getCells()\r\n    });\r\n\r\n    game.board.addEventListener(\"end\", (e) => {\r\n        const { winner } = (\r\n            e as CustomEvent<{\r\n                winner: playerValue\r\n            }>\r\n        ).detail;\r\n        self.emit(\"end\", {\r\n            winner\r\n        });\r\n    });\r\n\r\n    game.board.addEventListener(\"boardChange\", (e) => {\r\n        const { verticals, horizontals, cells } = (\r\n            e as CustomEvent<{\r\n                verticals: playValue[][];\r\n                horizontals: playValue[][];\r\n                cells: playValue[][];\r\n            }>\r\n        ).detail;\r\n\r\n        self.emit(\"change\", {\r\n            verticals,\r\n            horizontals,\r\n            score: game!.board.getScore(),\r\n            tour: game!.board.getTour(),\r\n            cells\r\n        });\r\n    });\r\n});\r\n\r\n\r\nfunction createPlayer(player: MainToWorkerEventMap[\"start\"][\"detail\"][\"player1\"]) {\r\n    switch (player.type) {\r\n        case \"human\":\r\n            return new HumanPlayer();\r\n        case \"random\":\r\n            return new RandomPlayer();\r\n        case \"minimax\":\r\n            return new MinimaxPlayer(player);\r\n        case \"alphabeta\":\r\n            return new AlphaBetaPlayer(player);\r\n        case \"mcts\":\r\n            return new MctsPlayer(player);\r\n        case \"fastest\":\r\n            return new FastestPlayer(player);\r\n    }\r\n}\r\n\r\n\r\nexport { };\r\n\r\n"],"names":["__webpack_require__","chunkId","obj","prop","Object","prototype","hasOwnProperty","call","b","self","location","Game","EventTarget","constructor","size","player1","player2","super","board","players","this","Board","play","getTour","then","coup","orientation","x","y","isFinished","BoardOrSize","cells","verticals","horizontals","score","tour","Array","fill","map","getCells","getVerticals","getHorizontals","getScore","result","check","push","length","forEach","cell","dispatchEvent","CustomEvent","detail","winner","_this$horizontals","evaluation","idPlayer","copy","row","getNodesVertical","playable","flatMap","value","filter","_ref","splice","Math","floor","random","lastTour","node","getNodes","getNodesHorizontal","_ref2","doneHorizontal","doneVertical","done","next","MctsNode","player","simulation","c","parent","arguments","undefined","wins","visits","nodes","generator","Map","run","i","backpropagation","simulate","newChild","expansion","bestNode","selection","bestValue","Infinity","_orientation","_x","_y","sqrt","log","endBoard","child","mapOrientation","get","set","mapX","won","getBestChild","getNumberVisited","negamax","depth","maximizingPlayer","nigamax","alpha","beta","max","Player","totalTime","totalMove","times","HumanPlayer","Promise","resolve","start","performance","now","addEventListener","e","end","console","concat","name","table","once","iaPlayer","all","playIa","setTimeout","MctsPlayer","iteration","root","bestChild","RandomPlayer","MinimaxPlayer","FastestPlayer","_ref3","ias","workers","race","ia","worker","Worker","URL","postMessage","JSON","parse","stringify","type","data","_ref4","terminate","AlphaBetaPlayer","_ref5","DedicatedWorkerGlobalScope","emit","game","formatNode","children","createPlayer","player1Instance","player2Instance","tree"],"sourceRoot":""}