{"version":3,"file":"static/js/472.63d11d41.chunk.js","mappings":"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","sources":["utils/game.ts","utils/mcts.ts","utils/player.ts","utils/negamax.ts","utils/nigamax.ts","playerWorker.ts","../webpack/bootstrap","../webpack/runtime/get javascript chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/startup"],"sourcesContent":["import { Player } from \"./player\";\r\n\r\nexport default class Game extends EventTarget {\r\n  readonly board: Board;\r\n  private players: [Player, Player];\r\n\r\n  constructor(size: number, player1: Player, player2: Player) {\r\n    super();\r\n    this.board = new Board(size);\r\n    this.players = [player1, player2];\r\n    this.play();\r\n  }\r\n\r\n  public async play() {\r\n    await this.players[this.board.getTour()].play(this.board, this.board.getTour()).then((coup) => {\r\n      this.board.play(coup.orientation, coup.x, coup.y);\r\n      if (!this.board.isFinished()) this.play();\r\n    });\r\n  }\r\n}\r\n\r\nexport type playValue = -1 | 0 | 1;\r\nexport type playerValue = 0 | 1;\r\n\r\nexport class Board extends EventTarget {\r\n  private cells: playValue[][] = [];\r\n  private verticals: playValue[][] = [];\r\n  private horizontals: playValue[][] = [];\r\n\r\n  private score: [number, number] = [0, 0];\r\n\r\n  private tour: playerValue = 0;\r\n\r\n  constructor(size: number);\r\n  constructor(board: { cells: playValue[][]; verticals: playValue[][]; horizontals: playValue[][]; score: [number, number]; tour: playerValue });\r\n  constructor(BoardOrSize: number | { cells: playValue[][]; verticals: playValue[][]; horizontals: playValue[][]; score: [number, number]; tour: playerValue }) {\r\n    super();\r\n    if (typeof BoardOrSize === \"number\") {\r\n      this.cells = new Array(BoardOrSize).fill(0).map(() => new Array(BoardOrSize).fill(-1));\r\n      this.verticals = new Array(BoardOrSize)\r\n        .fill(0)\r\n        .map(() => new Array(BoardOrSize + 1).fill(-1));\r\n      this.horizontals = new Array(BoardOrSize + 1)\r\n        .fill(0)\r\n        .map(() => new Array(BoardOrSize).fill(-1));\r\n      this.score = [0, 0];\r\n      this.tour = 0;\r\n    } else {\r\n      this.cells = BoardOrSize.cells;\r\n      this.verticals = BoardOrSize.verticals;\r\n      this.horizontals = BoardOrSize.horizontals;\r\n      this.score = BoardOrSize.score;\r\n      this.tour = BoardOrSize.tour;\r\n    }\r\n  }\r\n\r\n  public getCells(): playValue[][] {\r\n    return this.cells;\r\n  }\r\n\r\n  public getVerticals(): playValue[][] {\r\n    return this.verticals;\r\n  }\r\n\r\n  public getHorizontals(): playValue[][] {\r\n    return this.horizontals;\r\n  }\r\n\r\n  public getScore(): [number, number] {\r\n    return this.score;\r\n  }\r\n\r\n  public getTour(): playerValue {\r\n    return this.tour;\r\n  }\r\n\r\n  public play(\r\n    orientation: \"vertical\" | \"horizontal\",\r\n    x: number,\r\n    y: number\r\n  ): void {\r\n    if (orientation === \"vertical\") {\r\n      if (this.verticals[y][x] !== -1) return;\r\n      this.verticals[y][x] = this.tour;\r\n    } else {\r\n      if (this.horizontals[y][x] !== -1) return;\r\n      this.horizontals[y][x] = this.tour;\r\n    }\r\n\r\n    const cells: Array<[x: number, y: number]> = [];\r\n\r\n    if (orientation === \"horizontal\") {\r\n      let result = this.check(x, y);\r\n      if (result) cells.push(result);\r\n      result = this.check(x, y - 1);\r\n      if (result) cells.push(result);\r\n    } else {\r\n      let result = this.check(x, y);\r\n      if (result) cells.push(result);\r\n      result = this.check(x - 1, y);\r\n      if (result) cells.push(result);\r\n    }\r\n\r\n    if (!cells.length) {\r\n      this.tour = this.tour === 1 ? 0 : 1;\r\n    } else {\r\n      this.score[this.tour] += cells.length;\r\n\r\n      cells.forEach((cell) => {\r\n        this.cells[cell[1]][cell[0]] = this.tour;\r\n      });\r\n    }\r\n\r\n    this.dispatchEvent(\r\n      new CustomEvent(\"boardChange\", {\r\n        detail: {\r\n          verticals: this.verticals,\r\n          horizontals: this.horizontals,\r\n          cells: this.cells,\r\n          score: this.score,\r\n        },\r\n      })\r\n    );\r\n\r\n\r\n    if (this.isFinished()) {\r\n      const winner = this.score[0] === this.score[1] ? -1 : this.score[0] > this.score[1] ? 0 : 1;\r\n      this.dispatchEvent(new CustomEvent(\"end\", { detail: { winner } }));\r\n    }\r\n  }\r\n\r\n  public isFinished() {\r\n    return this.score[0] > this.cells.length ** 2 / 2 || this.score[1] > this.cells.length ** 2 / 2 || this.score[0] + this.score[1] === this.cells.length ** 2;\r\n  }\r\n\r\n  private check(x: number, y: number): false | [x: number, y: number] {\r\n    if (x < 0 || x >= this.cells.length || y < 0 || y >= this.cells.length) {\r\n      return false;\r\n    }\r\n    if (\r\n      this.verticals[y][x] !== -1 &&\r\n      this.verticals[y][x + 1] !== -1 &&\r\n      this.horizontals[y][x] !== -1 &&\r\n      this.horizontals[y + 1]?.[x] !== -1\r\n    ) {\r\n      return [x, y];\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public evaluation(idPlayer: playerValue) {\r\n    return this.score[idPlayer] - this.score[idPlayer === 1 ? 0 : 1];\r\n  }\r\n\r\n  public copy() {\r\n    const board = new Board(this.cells.length);\r\n    board.cells = this.cells.map((row) => [...row]);\r\n    board.verticals = this.verticals.map((row) => [...row]);\r\n    board.horizontals = this.horizontals.map((row) => [...row]);\r\n    board.score = [...this.score];\r\n    board.tour = this.tour;\r\n    return board;\r\n  }\r\n\r\n  private *getNodesVertical(): Generator<\r\n    {\r\n      x: number;\r\n      y: number;\r\n      board: Board;\r\n      orientation: \"vertical\" | \"horizontal\";\r\n    },\r\n    void,\r\n    void\r\n  > {\r\n    const playable = this.verticals\r\n      .flatMap((row, y) => row.map((value, x) => ({ x, y, value })))\r\n      .filter(({ value }) => value === -1);\r\n\r\n    while (playable.length > 0) {\r\n      const { x, y } = playable.splice(\r\n        Math.floor(Math.random() * playable.length),\r\n        1\r\n      )[0];\r\n      const board = this.copy();\r\n      const lastTour = board.tour;\r\n      board.play(\"vertical\", x, y);\r\n      if (board.tour === lastTour && !board.isFinished()) {\r\n        for (const node of board.getNodes()) {\r\n          yield { ...node, x, y, orientation: \"vertical\" };\r\n        }\r\n      } else yield { x, y, board, orientation: \"vertical\" };\r\n    }\r\n  }\r\n\r\n  private *getNodesHorizontal(): Generator<\r\n    {\r\n      x: number;\r\n      y: number;\r\n      board: Board;\r\n      orientation: \"vertical\" | \"horizontal\";\r\n    },\r\n    void,\r\n    void\r\n  > {\r\n    const playable = this.horizontals\r\n      .flatMap((row, y) => row.map((value, x) => ({ x, y, value })))\r\n      .filter(({ value }) => value === -1);\r\n\r\n    while (playable.length > 0) {\r\n      const { x, y } = playable.splice(\r\n        Math.floor(Math.random() * playable.length),\r\n        1\r\n      )[0];\r\n      const board = this.copy();\r\n      const lastTour = board.tour;\r\n      board.play(\"horizontal\", x, y);\r\n      if (board.tour === lastTour && !board.isFinished()) {\r\n        for (const node of board.getNodes()) {\r\n          yield { ...node, x, y, orientation: \"horizontal\" };\r\n        }\r\n      } else yield { x, y, board, orientation: \"horizontal\" };\r\n    }\r\n  }\r\n\r\n  public *getNodes(): Generator<\r\n    {\r\n      x: number;\r\n      y: number;\r\n      board: Board;\r\n      orientation: \"vertical\" | \"horizontal\";\r\n    },\r\n    void,\r\n    void\r\n  > {\r\n    const verticals = this.getNodesVertical();\r\n    const horizontals = this.getNodesHorizontal();\r\n\r\n    let doneHorizontal = false;\r\n    let doneVertical = false;\r\n\r\n    while (!doneHorizontal && !doneVertical) {\r\n      if (Math.random() < 0.5) {\r\n        const { value, done } = verticals.next();\r\n        if (done) doneVertical = true;\r\n        else yield value;\r\n      } else {\r\n        const { value, done } = horizontals.next();\r\n        if (done) doneHorizontal = true;\r\n        else yield value;\r\n      }\r\n    }\r\n\r\n    if (!doneHorizontal) {\r\n      for (const value of horizontals) {\r\n        yield value;\r\n      }\r\n    }\r\n\r\n    if (!doneVertical) {\r\n      for (const value of verticals) {\r\n        yield value;\r\n      }\r\n    }\r\n  }\r\n\r\n  // public *getNodes(): Generator<{\r\n  //   x: number;\r\n  //   y: number;\r\n  //   board: Board;\r\n  //   orientation: \"vertical\" | \"horizontal\";\r\n  // }, void, void> {\r\n  //   for (let y = 0; y < this.verticals.length; y++) {\r\n  //     for (let x = 0; x < this.verticals[y].length; x++) {\r\n  //       if (this.verticals[y][x] === 0) {\r\n  //         const board = this.copy();\r\n  //         const lastTour = board.tour;\r\n  //         board.play(\"vertical\", x, y);\r\n  //         if (board.tour === lastTour && !board.isFinished()) {\r\n  //           for (const node of board.getNodes()) {\r\n  //             yield { ...node, x, y, orientation: \"vertical\" };\r\n  //           }\r\n  //         }\r\n  //         else yield { x, y, board, orientation: \"vertical\" };\r\n  //       }\r\n  //     }\r\n  //   }\r\n\r\n  //   for (let y = 0; y < this.horizontals.length; y++) {\r\n  //     for (let x = 0; x < this.horizontals[y].length; x++) {\r\n  //       if (this.horizontals[y][x] === 0) {\r\n  //         const board = this.copy();\r\n  //         const lastTour = board.tour;\r\n  //         board.play(\"horizontal\", x, y);\r\n  //         if (board.tour === lastTour && !board.isFinished()) {\r\n  //           for (const node of board.getNodes()) {\r\n  //             yield { ...node, x, y, orientation: \"horizontal\" };\r\n  //           }\r\n  //         }\r\n  //         else yield { x, y, board, orientation: \"horizontal\" };\r\n  //       }\r\n  //     }\r\n  //   }\r\n  // }\r\n}\r\n\r\n\r\n","import { Board } from \"./game\";\r\n\r\n\r\nexport class MctsNode {\r\n    public wins: number;\r\n    public visits: number;\r\n    public nodes: Map<\"vertical\" | \"horizontal\", Map<number, Map<number, MctsNode>>>;\r\n    public parent: MctsNode | null;\r\n    private board: Board;\r\n    private player: 0 | 1;\r\n    private simulation: number;\r\n    private c: number\r\n    private generator: Generator<{ orientation: \"vertical\" | \"horizontal\"; x: number; y: number, board: Board }, void, unknown>;\r\n\r\n    constructor(board: Board, player: 0 | 1, simulation: number, c: number, parent: MctsNode | null = null) {\r\n        this.wins = 0;\r\n        this.visits = 0;\r\n        this.nodes = new Map();\r\n        this.parent = parent;\r\n        this.generator = board.getNodes();\r\n        this.board = board;\r\n        this.simulation = simulation;\r\n        this.player = player;\r\n        this.c = c;\r\n    }\r\n\r\n\r\n    public run() {\r\n        if (this.board.isFinished()) {\r\n            for (let i = 0; i < this.simulation; i++) {\r\n                this.backpropagation(this.simulate());\r\n            }\r\n            return\r\n        }\r\n\r\n        let newChild = this.expansion()\r\n\r\n        if (newChild) {\r\n            for (let i = 0; i < this.simulation; i++) {\r\n                newChild.backpropagation(newChild.simulate());\r\n            }\r\n        }\r\n        else {\r\n            const { bestNode } = this.selection();\r\n            bestNode.run();\r\n        }\r\n    }\r\n\r\n    private selection(): {\r\n        bestNode: MctsNode;\r\n        x: number;\r\n        y: number;\r\n        orientation: \"vertical\" | \"horizontal\";\r\n    } {\r\n        let bestNode: MctsNode | null = null;\r\n        let x: number = 0;\r\n        let y: number = 0;\r\n        let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n        let bestValue = -Infinity;\r\n        this.nodes.forEach((row, _orientation) => {\r\n            row.forEach((cell, _x) => {\r\n                cell.forEach((node, _y) => {\r\n                    const value = node.wins / node.visits + this.c * Math.sqrt(2 * Math.log(this.visits) / node.visits);\r\n                    if (value > bestValue) {\r\n                        bestValue = value;\r\n                        orientation = _orientation as \"vertical\" | \"horizontal\";\r\n                        x = +_x;\r\n                        y = +_y;\r\n                        bestNode = node;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return { bestNode: bestNode!, x, y, orientation };\r\n    }\r\n\r\n    private simulate() {\r\n        \r\n        let gen = this.board.getNodes();\r\n        const result = this.board.copy();\r\n        for (let node of gen) {\r\n            result.play(node.orientation, node.x, node.y);\r\n            if (node.board.isFinished()) {\r\n                break;\r\n            }\r\n        }\r\n        return result.getScore()[this.player] > result.getScore()[this.player === 1 ? 0 : 1];\r\n    }\r\n\r\n    private expansion() {\r\n        const { value, done } = this.generator.next();\r\n\r\n        if (done) return false;\r\n\r\n        const { orientation, x, y, board } = value;\r\n        const child = new MctsNode(board, this.player, this.simulation, this.c, this);\r\n        let mapOrientation = this.nodes.get(orientation);\r\n        if (!mapOrientation) {\r\n            mapOrientation = new Map();\r\n            this.nodes.set(orientation, mapOrientation);\r\n        }\r\n\r\n        let mapX = mapOrientation.get(x);\r\n        if (!mapX) {\r\n            mapX = new Map();\r\n            mapOrientation.set(x, mapX);\r\n        }\r\n\r\n        mapX.set(y, child);\r\n\r\n        return child;\r\n    }\r\n\r\n    private backpropagation(won: boolean) {\r\n        if (won) {\r\n            this.wins++;\r\n        }\r\n        this.visits++;\r\n        if (this.parent) {\r\n            this.parent.backpropagation(won);\r\n        }\r\n    }\r\n\r\n    public getBestChild() {\r\n        let bestNode: MctsNode | null = null;\r\n        let x: number = 0;\r\n        let y: number = 0;\r\n        let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n        let bestValue = -Infinity;\r\n        this.nodes.forEach((row, _orientation) => {\r\n            row.forEach((cell, _x) => {\r\n                cell.forEach((node, _y) => {\r\n                    const value = node.wins / node.visits;\r\n                    if (value > bestValue) {\r\n                        orientation = _orientation as \"vertical\" | \"horizontal\";\r\n                        x = +_x;\r\n                        y = +_y;\r\n                        bestValue = value;\r\n                        bestNode = node;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return { bestNode: bestNode!, x, y, orientation };\r\n    }\r\n\r\n    getNumberVisited() {\r\n        return this.visits;\r\n    }\r\n\r\n}","import { Board } from \"./game\";\r\nimport { MctsNode } from \"./mcts\";\r\nimport negamax from \"./negamax\";\r\nimport nigamax from \"./nigamax\";\r\n\r\nexport interface Coup {\r\n    x: number,\r\n    y: number,\r\n    orientation: \"vertical\" | \"horizontal\"\r\n}\r\n\r\nexport abstract class Player extends EventTarget {\r\n    protected totalTime: number = 0;\r\n    protected totalMove: number = 0;\r\n    protected times: number[] = [];\r\n\r\n    abstract play(board: Board, player: 0 | 1): Promise<Coup>\r\n}\r\n\r\nexport class HumanPlayer extends Player {\r\n    play(board: Board, player: 0 | 1) {\r\n        return new Promise<Coup>((resolve) => {\r\n            const start = performance.now()\r\n            this.addEventListener(\"play\", (e: Event) => {\r\n                const end = performance.now()\r\n                this.totalTime += end - start\r\n                this.totalMove++\r\n                this.times.push(end - start)\r\n                console.log(`Player ${player} (${(this as any).constructor.name}) Time: ${end - start} Average time: ${this.totalTime / this.totalMove}ms`)\r\n                const customEvent = e as CustomEvent<{ x: number, y: number, orientation: \"vertical\" | \"horizontal\" }>;\r\n                resolve(customEvent.detail);\r\n            }, { once: true })\r\n        })\r\n    }\r\n}\r\n\r\nexport abstract class iaPlayer extends Player {\r\n    async play(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return (await Promise.all([\r\n            (async (): Promise<Coup> => {\r\n                const start = performance.now()\r\n                const result = await this.playIa(board, player)\r\n                const end = performance.now()\r\n                this.totalTime += end - start\r\n                this.totalMove++\r\n                this.times.push(end - start)\r\n                console.log(`Player ${player} (${(this as any).constructor.name}) Time: ${end - start} Average time: ${this.totalTime / this.totalMove}ms`)\r\n                return result\r\n            })(),\r\n            //delay to see the move\r\n            new Promise<void>((resolve) => {\r\n                setTimeout(() => {\r\n                    resolve()\r\n                }, 500)\r\n            })\r\n        ]))[0]\r\n    }\r\n\r\n    abstract playIa(board: Board, player: number): Promise<Coup>;\r\n}\r\n\r\nexport class MctsPlayer extends iaPlayer {\r\n    private iteration: number;\r\n    private simulation: number;\r\n    private c: number\r\n    private lastBoard: Board | null = null;\r\n    private lastNode: MctsNode | null = null;\r\n\r\n    constructor({ iteration, simulation, c }: { iteration: number, simulation: number, c?: number }) {\r\n        super();\r\n        this.iteration = iteration;\r\n        this.simulation = simulation;\r\n        this.c = c || Math.sqrt(2);\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            let bestNode: MctsNode | null = null;\r\n            if (this.lastBoard && this.lastNode) {\r\n                const played = this.lastBoard\r\n                    .getHorizontals()\r\n                    .flatMap((row, y) => row.map((cell, x) => cell === -1 && board.getHorizontals()[y][x] !== -1 ? { x, y, orientation: \"horizontal\" } : null))\r\n                    .filter(x => x)\r\n                    .concat(\r\n                        this.lastBoard\r\n                            .getVerticals()\r\n                            .flatMap((row, y) => row.map((cell, x) => cell === -1 && board.getVerticals()[y][x] !== -1 ? { x, y, orientation: \"vertical\" } : null))\r\n                            .filter(x => x)\r\n                    ) as { x: number, y: number, orientation: \"vertical\" | \"horizontal\" }[]\r\n\r\n                if (played.length === 0) {\r\n                    bestNode = this.lastNode;\r\n                }\r\n\r\n\r\n                let bestValue = -Infinity;\r\n                if (played.length > 0) {\r\n                    for (const coup of permute(played)) {\r\n                        let currentNode: MctsNode | null = this.lastNode!.nodes.get(coup[0].orientation)?.get(coup[0].x)?.get(coup[0].y) || null;\r\n                        for (let i = 1; i < coup.length; i++) {\r\n                            currentNode = currentNode?.nodes.get(coup[i].orientation)?.get(coup[i].x)?.get(coup[i].y) || null;\r\n                            if (!currentNode) break;\r\n                        }\r\n                        if (currentNode) {\r\n                            if (currentNode.wins > bestValue) {\r\n                                bestValue = currentNode.wins;\r\n                                bestNode = currentNode;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            let root = bestNode || new MctsNode(board, player, this.simulation, this.c);\r\n            while (root.getNumberVisited() < this.iteration * this.simulation) {\r\n                root.run();\r\n            }\r\n            this.dispatchEvent(new CustomEvent(\"tree\", { detail: root }));\r\n            let bestChild = root.getBestChild();\r\n            this.lastNode = bestChild.bestNode;\r\n            board.play(bestChild.orientation, bestChild.x, bestChild.y);\r\n            this.lastBoard = board.copy();\r\n            resolve({ x: bestChild.x, y: bestChild.y, orientation: bestChild.orientation });\r\n        })\r\n    }\r\n}\r\n\r\nexport class RandomPlayer extends iaPlayer {\r\n    playIa(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            const { orientation, x, y } = board.getNodes().next().value!\r\n            resolve({ x, y, orientation });\r\n        })\r\n    }\r\n}\r\n\r\nexport class MinimaxPlayer extends iaPlayer {\r\n    private depth: number;\r\n\r\n    constructor({ depth }: { depth: number }) {\r\n        super();\r\n        this.depth = depth;\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            const { nodes, ...coup } = negamax(board, this.depth, true, player)\r\n            console.log(`Player ${player} (${(this as any).constructor.name}) : ${nodes} nodes`)\r\n            resolve(coup);\r\n        })\r\n    }\r\n}\r\n\r\nexport class FastestPlayer extends iaPlayer {\r\n    private depth: number;\r\n    private ias: (\"minimax\" | \"alphabeta\" | \"mcts\")[] = [\"minimax\", \"alphabeta\", \"mcts\"]\r\n\r\n    constructor({ depth }: { depth: number }) {\r\n        super();\r\n        this.depth = depth;\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1) {\r\n        const workers: Worker[] = []\r\n\r\n        return Promise.race(this.ias.map(ia => {\r\n            return new Promise<[Coup, typeof ia]>((resolve) => {\r\n                const worker = new Worker(new URL(\"../playerWorker.ts\", import.meta.url));\r\n                workers.push(worker)\r\n                worker.postMessage({ board: JSON.parse(JSON.stringify(board)), depth: this.depth, player, type: ia });\r\n                worker.addEventListener(\"message\", (e) => {\r\n                    resolve([e.data, ia]);\r\n                })\r\n            })\r\n        })).then(([coup, ia]) => {\r\n            workers.forEach(worker => worker.terminate())\r\n            console.log(ia)\r\n            return coup\r\n        })\r\n\r\n    }\r\n}\r\n\r\n\r\nexport class AlphaBetaPlayer extends iaPlayer {\r\n    private depth: number;\r\n\r\n    constructor({ depth }: { depth: number }) {\r\n        super();\r\n        this.depth = depth;\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1) {\r\n        return new Promise<Coup>((resolve) => {\r\n            const { nodes, ...coup } = nigamax(board, this.depth, true, player)\r\n            console.log(`Player ${player} (${(this as any).constructor.name}) : ${nodes} nodes`)\r\n            resolve(coup);\r\n        })\r\n    }\r\n}\r\n\r\n\r\nfunction permute<T>(arr: T[]): T[][] {\r\n    let results: T[][] = [];\r\n\r\n    function permuteRecursively(subArr: T[], memo: T[]) {\r\n        if (subArr.length === 0) {\r\n            results.push(memo.slice());\r\n        } else {\r\n            for (let i = 0; i < subArr.length; i++) {\r\n                let curr = subArr.slice();\r\n                let next = curr.splice(i, 1);\r\n                permuteRecursively(curr, memo.concat(next));\r\n            }\r\n        }\r\n    }\r\n\r\n    permuteRecursively(arr, []);\r\n    return results;\r\n}","import { Board, playerValue } from \"./game\";\r\nimport { Coup } from \"./player\";\r\n\r\nexport default function negamax(board: Board, _depth: number, maximizingPlayer: boolean, idPlayer: playerValue): {\r\n  x: number;\r\n  y: number;\r\n  value: number;\r\n  orientation: \"vertical\" | \"horizontal\";\r\n  nodes: number;\r\n} {\r\n  let x = 0, y = 0, orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n  let nodes = 0;\r\n  function _negamax(board: Board, depth: number, maximizingPlayer: boolean): number {\r\n    if (depth === 0 || board.isFinished())\r\n      return board.evaluation(idPlayer) * (maximizingPlayer ? 1 : -1)\r\n    let value = -Infinity;\r\n    for (const { board: node, x: _x, y: _y, orientation: _orientation } of board.getNodes()) {\r\n      nodes++;\r\n      const result = _negamax(node, depth - 1, !maximizingPlayer);\r\n      if (-result > value) {\r\n        if (depth === _depth) {\r\n          x = _x;\r\n          y = _y;\r\n          orientation = _orientation;\r\n        }\r\n        value = -result;\r\n      }\r\n    }\r\n    return value;\r\n  }\r\n  const value = _negamax(board, _depth, maximizingPlayer)\r\n\r\n  return {\r\n    x,\r\n    y,\r\n    orientation,\r\n    value,\r\n    nodes\r\n  };\r\n}","import { Board, playerValue } from \"./game\";\r\n\r\nexport default function nigamax(board: Board, _depth: number, maximizingPlayer: boolean, idPlayer: playerValue, alpha: number = -Infinity, beta: number = Infinity): {\r\n  x: number;\r\n  y: number;\r\n  value: number;\r\n  orientation: \"vertical\" | \"horizontal\";\r\n  nodes: number;\r\n} {\r\n  let x = 0, y = 0, orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n  let nodes = 0;\r\n  function _nigamax(board: Board, depth: number, maximizingPlayer: boolean, alpha: number = -Infinity, beta: number = Infinity): number {\r\n    if (depth === 0 || board.isFinished()) {\r\n      return board.evaluation(idPlayer) * (maximizingPlayer ? 1 : -1)\r\n    }\r\n    let value = -Infinity;\r\n    for (const { board: node, x: _x, y: _y, orientation: _orientation } of board.getNodes()) {\r\n      nodes++;\r\n      const result = _nigamax(node, depth - 1, !maximizingPlayer, -beta, -alpha);\r\n      if (-result > value) {\r\n        value = -result;\r\n        if (depth === _depth) {\r\n          x = _x;\r\n          y = _y;\r\n          orientation = _orientation;\r\n        }\r\n      }\r\n      if (value >= beta) {\r\n        return value\r\n      }\r\n      alpha = Math.max(alpha, value);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  const value = _nigamax(board, _depth, maximizingPlayer, alpha, beta)\r\n  return {\r\n    value,\r\n    x,\r\n    y,\r\n    orientation,\r\n    nodes\r\n  };\r\n}\r\n","import { Board } from \"./utils/game\";\r\nimport { AlphaBetaPlayer, HumanPlayer, MctsPlayer, MinimaxPlayer, Player, RandomPlayer } from \"./utils/player\";\r\n\r\ndeclare var self: DedicatedWorkerGlobalScope;\r\n\r\n//remove console.log\r\nconsole.log = () => { }\r\n\r\nself.addEventListener(\"message\", ({ data: { board, player, type } }: {\r\n    data: {\r\n        board: any, player: any, type: string\r\n    }\r\n}) => {\r\n    let playerType: Player;\r\n    switch (type) {\r\n        case \"human\":\r\n            playerType = new HumanPlayer()\r\n            break;\r\n        case \"random\":\r\n            playerType = new RandomPlayer()\r\n            break;\r\n        case \"minimax\":\r\n            playerType = new MinimaxPlayer({ depth: 3 })\r\n            break;\r\n        case \"alphabeta\":\r\n            playerType = new AlphaBetaPlayer({ depth: 3 })\r\n            break;\r\n        case \"mcts\":\r\n            playerType = new MctsPlayer({ iteration: 1000, c: 1.41, simulation: 10 })\r\n            break;\r\n        default:\r\n            throw new Error(\"Invalid player type\")\r\n    }\r\n\r\n\r\n    playerType.play(new Board(board), player).then((coup) => {\r\n        self.postMessage(coup);\r\n    })\r\n});\r\n\r\n\r\n\r\nexport { };\r\n\r\n","// The require scope\nvar __webpack_require__ = {};\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"63d11d41\" + \".chunk.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/POLYTECH-IA-PROJET-PIPOPIPETTE/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t472: 1\n};\n\n// no chunk install function needed\n// no chunk loading\n\n// no HMR\n\n// no HMR manifest","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[4472](0, __webpack_exports__, __webpack_require__);\n"],"names":["EventTarget","Board","constructor","BoardOrSize","super","cells","verticals","horizontals","score","tour","this","Array","fill","map","getCells","getVerticals","getHorizontals","getScore","getTour","play","orientation","x","y","result","check","push","length","forEach","cell","dispatchEvent","CustomEvent","detail","isFinished","winner","_this$horizontals","evaluation","idPlayer","copy","board","row","getNodesVertical","playable","flatMap","value","filter","_ref","splice","Math","floor","random","lastTour","node","getNodes","getNodesHorizontal","_ref2","doneHorizontal","doneVertical","done","next","MctsNode","player","simulation","c","parent","arguments","undefined","wins","visits","nodes","generator","Map","run","i","backpropagation","simulate","newChild","expansion","bestNode","selection","bestValue","Infinity","_orientation","_x","_y","sqrt","log","gen","child","mapOrientation","get","set","mapX","won","getBestChild","getNumberVisited","Player","totalTime","totalMove","times","HumanPlayer","Promise","resolve","start","performance","now","addEventListener","e","end","console","concat","name","once","iaPlayer","all","playIa","setTimeout","MctsPlayer","iteration","lastBoard","lastNode","played","coup","arr","results","permuteRecursively","subArr","memo","slice","curr","permute","_nodes$get","_nodes$get$get","currentNode","_currentNode","_currentNode$nodes$ge","_currentNode$nodes$ge2","root","bestChild","RandomPlayer","MinimaxPlayer","depth","_depth","maximizingPlayer","_negamax","negamax","AlphaBetaPlayer","_ref5","_nigamax","alpha","beta","max","nigamax","self","playerType","data","type","Error","then","postMessage","__webpack_require__","m","__webpack_modules__","u","chunkId","o","obj","prop","Object","prototype","hasOwnProperty","call","p","b","location"],"sourceRoot":""}