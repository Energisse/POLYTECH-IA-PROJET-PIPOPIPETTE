{"version":3,"file":"static/js/661.46890f93.chunk.js","mappings":"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","sources":["utils/board.ts","utils/game.ts","utils/players/Player.ts","utils/players/IAPlayer.ts","utils/players/AlphaBetaPlayer.ts","utils/nigamax.ts","models/index.ts","utils/mctsAlphaZero.ts","utils/players/AlphaZeroPlayer.ts","utils/players/FastestPlayer.ts","utils/players/HumanPlayer.ts","utils/mcts.ts","utils/players/MCTSPlayer.ts","utils/players/MinimaxPlayer.ts","utils/negamax.ts","utils/players/RandomPlayer.ts","worker.ts","../webpack/bootstrap","../webpack/runtime/amd define","../webpack/runtime/amd options","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/create fake namespace object","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export type NodeGenerator = Generator<\r\n    {\r\n        x: number;\r\n        y: number;\r\n        board: Board;\r\n        orientation: \"vertical\" | \"horizontal\";\r\n    },\r\n    void,\r\n    void\r\n>;\r\n\r\nexport interface Coup {\r\n    x: number,\r\n    y: number,\r\n    orientation: \"vertical\" | \"horizontal\"\r\n}\r\n\r\nexport type PlayValue = -1 | 0 | 1;\r\nexport type PlayerValue = 0 | 1;\r\n\r\nexport class Board {\r\n    readonly cells: ReadonlyArray<ReadonlyArray<PlayValue>> = [];\r\n    readonly verticals: ReadonlyArray<ReadonlyArray<PlayValue>> = [];\r\n    readonly horizontals: ReadonlyArray<ReadonlyArray<PlayValue>> = [];\r\n    readonly previousBoard: Board | null = null;\r\n    readonly score: readonly [number, number] = [0, 0];\r\n    readonly tour: PlayerValue = 0;\r\n\r\n    constructor(size: number);\r\n    constructor(board: { cells: PlayValue[][]; verticals: PlayValue[][]; horizontals: PlayValue[][]; score: [number, number]; tour: PlayerValue, previousBoard?: Board });\r\n    constructor(BoardOrSize: number | { cells: PlayValue[][]; verticals: PlayValue[][]; horizontals: PlayValue[][]; score: [number, number]; tour: PlayerValue, previousBoard?: Board }) {\r\n        if (typeof BoardOrSize === \"number\") {\r\n            this.cells = new Array(BoardOrSize).fill(0).map(() => new Array(BoardOrSize).fill(-1));\r\n            this.verticals = new Array(BoardOrSize)\r\n                .fill(0)\r\n                .map(() => new Array(BoardOrSize + 1).fill(-1));\r\n            this.horizontals = new Array(BoardOrSize + 1)\r\n                .fill(0)\r\n                .map(() => new Array(BoardOrSize).fill(-1));\r\n            this.score = [0, 0];\r\n            this.tour = 0;\r\n        } else {\r\n            this.cells = BoardOrSize.cells;\r\n            this.verticals = BoardOrSize.verticals;\r\n            this.horizontals = BoardOrSize.horizontals;\r\n            this.score = BoardOrSize.score;\r\n            this.tour = BoardOrSize.tour;\r\n            this.previousBoard = BoardOrSize.previousBoard || null;\r\n        }\r\n    }\r\n\r\n    public getWinner(): -1 | 0 | 1 {\r\n        return this.score[0] > this.score[1] ? 0 : this.score[0] < this.score[1] ? 1 : -1;\r\n    }\r\n\r\n    public play(\r\n        orientation: \"vertical\" | \"horizontal\",\r\n        x: number,\r\n        y: number\r\n    ): Board | null {\r\n\r\n        const newHorizontals = this.horizontals.map((row) => [...row]);\r\n        const newVerticals = this.verticals.map((row) => [...row]);\r\n        const newCells = this.cells.map((row) => [...row]);\r\n        const newScore = [...this.score];\r\n        let newTour = this.tour;\r\n\r\n        if (orientation === \"vertical\") {\r\n            if (newVerticals[y][x] !== -1) {\r\n                console.error(\"Invalid move \" + orientation + x + y)\r\n                return null;\r\n            }\r\n            newVerticals[y][x] = this.tour;\r\n        } else {\r\n            if (newHorizontals[y][x] !== -1) {\r\n                console.error(\"Invalid move \" + orientation + x + y);\r\n                return null;\r\n            }\r\n            newHorizontals[y][x] = this.tour;\r\n\r\n\r\n        }\r\n\r\n        const cells: Array<[x: number, y: number]> = [];\r\n\r\n        if (orientation === \"horizontal\") {\r\n            let result = this.check(newHorizontals, newVerticals, x, y);\r\n            if (result) cells.push(result);\r\n            result = this.check(newHorizontals, newVerticals, x, y - 1);\r\n            if (result) cells.push(result);\r\n        } else {\r\n            let result = this.check(newHorizontals, newVerticals, x, y);\r\n            if (result) cells.push(result);\r\n            result = this.check(newHorizontals, newVerticals, x - 1, y);\r\n            if (result) cells.push(result);\r\n        }\r\n\r\n        if (!cells.length) {\r\n            newTour = newTour === 1 ? 0 : 1;\r\n        } else {\r\n            newScore[newTour] += cells.length;\r\n\r\n            cells.forEach((cell) => {\r\n                newCells[cell[1]][cell[0]] = newTour;\r\n            });\r\n        }\r\n\r\n        return new Board({\r\n            cells: newCells,\r\n            verticals: newVerticals,\r\n            horizontals: newHorizontals,\r\n            score: newScore as [number, number],\r\n            tour: newTour,\r\n            previousBoard: this\r\n        });\r\n    }\r\n\r\n    public isFinished() {\r\n        return this.score[0] > this.cells.length ** 2 / 2 || this.score[1] > this.cells.length ** 2 / 2 || this.score[0] + this.score[1] === this.cells.length ** 2;\r\n    }\r\n\r\n    private check(horizontals: PlayValue[][], verticals: PlayValue[][], x: number, y: number): false | [x: number, y: number] {\r\n        if (x < 0 || x >= this.cells.length || y < 0 || y >= this.cells.length) {\r\n            return false;\r\n        }\r\n        if (\r\n            verticals[y][x] !== -1 &&\r\n            verticals[y][x + 1] !== -1 &&\r\n            horizontals[y][x] !== -1 &&\r\n            horizontals[y + 1]?.[x] !== -1\r\n        ) {\r\n            return [x, y];\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public evaluation(idPlayer: PlayerValue) {\r\n        return this.score[idPlayer] - this.score[idPlayer === 1 ? 0 : 1];\r\n    }\r\n\r\n\r\n    public *getNodes(depthLimit?: number): NodeGenerator {\r\n        const playable = [\r\n            ...this.verticals\r\n                .flatMap((row, y) => row.map((value, x) => ({ x, y, value, orientation: \"vertical\" } satisfies Coup & { value: number }))),\r\n            ...this.horizontals\r\n                .flatMap((row, y) => row.map((value, x) => ({ x, y, value, orientation: \"horizontal\" } satisfies Coup & { value: number })))\r\n        ]\r\n            .filter(({ value }) => value === -1)\r\n\r\n\r\n        let currentIndex = playable.length;\r\n        while (currentIndex !== 0) {\r\n\r\n            let randomIndex = Math.floor(Math.random() * currentIndex);\r\n            currentIndex--;\r\n\r\n            // And swap it with the current element.\r\n            [playable[currentIndex], playable[randomIndex]] = [\r\n                playable[randomIndex], playable[currentIndex]];\r\n        }\r\n\r\n        for (let i = 0; i < playable.length; i++) {\r\n            const { x, y, orientation } = playable[i];\r\n            const board = this.play(orientation, x, y)!;\r\n            if (board.tour === board.previousBoard!.tour && !board.isFinished() && (depthLimit === undefined || depthLimit > 0)) {\r\n                for (const node of board.getNodes(depthLimit ? depthLimit - 1 : undefined)) {\r\n                    yield { ...node, x, y, orientation };\r\n                }\r\n            } else yield { x, y, board, orientation };\r\n        }\r\n    }\r\n}\r\n\r\n\r\n","import { Board } from \"./board\";\r\nimport { Player } from \"./players/Player\";\r\nexport default class Game extends EventTarget {\r\n  private board: Board;\r\n  private players: [Player, Player];\r\n  private playing: boolean = false;\r\n\r\n  constructor(size: number, player1: Player, player2: Player) {\r\n    super();\r\n    this.board = new Board(size);\r\n    this.players = [player1, player2];\r\n    this.play();\r\n  }\r\n\r\n  getBoard() {\r\n    return this.board;\r\n  }\r\n\r\n  private async play() {\r\n    if (this.playing) return;\r\n    this.playing = true;\r\n    while (!this.board.isFinished()) {\r\n      await this.players[this.board.tour].play(this.board, this.board.tour).then((coup) => {\r\n        const newBoard = this.board.play(coup.orientation, coup.x, coup.y)\r\n        if (newBoard) {\r\n          this.board = newBoard;\r\n          this.dispatchEvent(new CustomEvent(\"played\", {\r\n            detail: {\r\n              played: {\r\n                x: coup.x, y: coup.y, orientation: coup.orientation, player: newBoard.previousBoard!.tour\r\n              },\r\n              board: this.board\r\n            }\r\n          }));\r\n        }\r\n      });\r\n    }\r\n    const [player1, player2] = this.board.score\r\n\r\n    this.dispatchEvent(new CustomEvent(\"end\", {\r\n      detail: {\r\n        winner: player1 > player2 ? 0 : player1 < player2 ? 1 : -1\r\n      }\r\n    }));\r\n  }\r\n\r\n  public async start() {\r\n    await this.play();\r\n  }\r\n}\r\n","import { Board, Coup, PlayerValue } from \"../board\";\r\n\r\n/**\r\n * Classe abstraite représentant un joueur dans le jeu.\r\n * Étend la classe EventTarget pour gérer les événements.\r\n */\r\nexport abstract class Player extends EventTarget {\r\n    /**\r\n     * Le temps total pris par le joueur.\r\n     */\r\n    protected totalTime: number = 0;\r\n\r\n    /**\r\n     * Le nombre total de mouvements effectués par le joueur.\r\n     */\r\n    protected totalMove: number = 0;\r\n\r\n    /**\r\n     * Un tableau pour stocker les temps pris pour chaque mouvement.\r\n     */\r\n    protected times: number[] = [];\r\n\r\n    /**\r\n     * Méthode abstraite à implémenter par les sous-classes pour effectuer un mouvement.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    abstract play(board: Board, player: PlayerValue): Promise<Coup>;\r\n}\r\n","import { Board, Coup, PlayerValue } from \"../board\";\r\nimport { Player } from \"./Player\";\r\n\r\n/**\r\n * Classe abstraite représentant un joueur IA.\r\n */\r\nexport abstract class IaPlayer extends Player {\r\n\r\n    /**\r\n     * Le temps minimal pour jouer un coup.\r\n     */\r\n    protected minTimeToPlay: number = 0;\r\n\r\n\r\n    /**\r\n     * \r\n     * @param {number} minTimeToPlay - Le temps minimal pour jouer un coup.\r\n     */\r\n    constructor({ minTimeToPlay }: { minTimeToPlay?: number }) {\r\n        super()\r\n        this.minTimeToPlay = minTimeToPlay || 500;\r\n    }\r\n\r\n    /**\r\n     * Joue un coup sur le plateau.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    async play(board: Board, player: PlayerValue): Promise<Coup> {\r\n        return (await Promise.all([\r\n            new Promise<Coup>(async (resolve) => {\r\n                const start = performance.now();\r\n                const result = await this.playIa(board, player);\r\n                const end = performance.now();\r\n\r\n                this.totalTime += end - start;\r\n                this.totalMove++;\r\n                this.times.push(end - start);\r\n\r\n                console.log(`Player ${player} (${this.constructor.name}) Time: ${end - start}ms Average time: ${this.totalTime / this.totalMove}ms`);\r\n\r\n                resolve(result);\r\n            }),\r\n            //Temps minimal de pour jouer\r\n            new Promise<void>((resolve) => setTimeout(resolve, this.minTimeToPlay))\r\n        ]))[0]\r\n    }\r\n\r\n    /**\r\n     * Méthode abstraite pour jouer un coup IA.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    abstract playIa(board: Board, player: PlayerValue): Promise<Coup>;\r\n}","import { Board, Coup, PlayerValue } from \"../board\";\r\nimport nigamax from \"../nigamax\";\r\nimport { IaPlayer } from \"./IAPlayer\";\r\n\r\nexport class AlphaBetaPlayer extends IaPlayer {\r\n    private depth: number;\r\n\r\n    private depthLimit?: number;\r\n\r\n    constructor(paramters: { depth: number, minTimeToPlay?: number, depthLimit?: number }) {\r\n        super(paramters);\r\n        this.depth = paramters.depth;\r\n        this.depthLimit = paramters.depthLimit;\r\n    }\r\n\r\n    playIa(board: Board, player: PlayerValue) {\r\n        return new Promise<Coup>((resolve) => {\r\n            const { nodes, ...coup } = nigamax(board, this.depth, player, this.depthLimit)\r\n            console.log(`Player ${player} (${(this as any).constructor.name}) : ${nodes} nodes`)\r\n            resolve(coup);\r\n        })\r\n    }\r\n}\r\n\r\n","import { Board, Coup, PlayerValue } from \"./board\";\r\n\r\nexport default function nigamax(board: Board, _depth: number, idPlayer: PlayerValue, depthLimit?: number): Coup & {\r\n  nodes: number;\r\n  value: number;\r\n} {\r\n  let coup: Coup = { x: 0, y: 0, orientation: \"horizontal\" };\r\n  let nodes = 0;\r\n\r\n  //key is horizontals stringified + verticals stringified + score stringified + nextPlayer stringified\r\n  //value is the evaluation\r\n  const history = new Map<string, number>();\r\n\r\n  function generateKey(board: Board): string {\r\n    return `${board.horizontals.map(h => h.map(e => e !== -1 ? 1 : 0).join(\"\")).join(\"\")}${board.verticals.map(h => h.map(e => e !== -1 ? 1 : 0).join(\"\")).join(\"\")}${board.score.join(\"\")}${board.tour}`;\r\n  }\r\n\r\n\r\n  function _nigamax(board: Board, depth: number, maximizingPlayer: boolean, alpha: number = -Infinity, beta: number = Infinity): number {\r\n    if (depth === 0 || board.isFinished())\r\n      return board.evaluation(idPlayer) * (maximizingPlayer ? 1 : -1)\r\n\r\n    let value = -Infinity;\r\n\r\n    for (const { board: node, ...coupPlayed } of board.getNodes(depthLimit)) {\r\n      nodes++;\r\n      const key = generateKey(node);\r\n\r\n      if (history.has(key)) {\r\n        value = Math.max(value, history.get(generateKey(node))!);\r\n      }\r\n      else {\r\n        const result = _nigamax(node, depth - 1, !maximizingPlayer, -beta, -alpha);\r\n        history.set(key, -result);\r\n\r\n        if (-result > value) {\r\n          if (depth === _depth) coup = coupPlayed\r\n          value = -result;\r\n        }\r\n      }\r\n\r\n      if (value >= beta) return value\r\n\r\n      alpha = Math.max(alpha, value);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  const value = _nigamax(board, _depth, true)\r\n\r\n  return {\r\n    value,\r\n    ...coup,\r\n    nodes\r\n  };\r\n}\r\n","import * as model_3x3_16_5_1 from './3x3_16_5_1.json';\r\n//@ts-ignore\r\nimport * as weights_3x3_16_5_1 from './3x3_16_5_1.weights';\r\n\r\nimport * as model_3x3_16_5_2 from './3x3_16_5_2.json';\r\n//@ts-ignore\r\nimport * as weights_3x3_16_5_2 from './3x3_16_5_2.weights';\r\n\r\nimport * as model_3x3_16_5_3 from './3x3_16_5_3.json';\r\n//@ts-ignore\r\nimport * as weights_3x3_16_5_3 from './3x3_16_5_3.weights';\r\n\r\nexport const models: Map<number, Map<string, { model: object, weights: string }>> = new Map()\r\n\r\nmodels.set(3, new Map([\r\n    [\"3x3_16_5_1\", { model: model_3x3_16_5_1, weights: weights_3x3_16_5_1 }],\r\n    [\"3x3_16_5_2\", { model: model_3x3_16_5_2, weights: weights_3x3_16_5_2 }],\r\n    [\"3x3_16_5_3\", { model: model_3x3_16_5_3, weights: weights_3x3_16_5_3 }],\r\n]))","import { LayersModel, Tensor } from \"@tensorflow/tfjs\";\r\nimport * as tf from \"@tensorflow/tfjs\"\r\nimport AlplhaZeroPlayer from \"./players/AlphaZeroPlayer\";\r\nimport { Board } from \"./board\";\r\n\r\n\r\nexport class MctsNodePipopipetteGo {\r\n    //le nombre de visites\r\n    public N: number;\r\n\r\n    //La valeur total des prochains noeuds\r\n    public W: number;\r\n\r\n    //La moyenne des valeurs des prochains noeuds\r\n    public Q: number;\r\n\r\n    //La probabilité de choisir ce noeud\r\n    public P: number\r\n\r\n    // public nodes: Map<\"vertical\" | \"horizontal\", Map<number, Map<number, MctsNodePipopipetteGo>>>;\r\n    public nodes: [\r\n        vertical: Array<Array<MctsNodePipopipetteGo>>,\r\n        horizontal: Array<Array<MctsNodePipopipetteGo>>,\r\n    ]\r\n\r\n    public expanded: boolean = false;\r\n\r\n    public parent: MctsNodePipopipetteGo | null;\r\n    public board: Board;\r\n    private player: 0 | 1;\r\n    private model: LayersModel;\r\n\r\n    constructor(model: LayersModel, board: Board, player: 0 | 1, parent: MctsNodePipopipetteGo | null = null) {\r\n        this.N = 0;\r\n        this.W = 0;\r\n        this.Q = 0;\r\n        this.P = 0;\r\n\r\n        this.nodes = [\r\n            Array.from({ length: board.verticals[0].length }, () => Array(board.verticals.length).fill(null)),\r\n            Array.from({ length: board.horizontals[0].length }, () => Array(board.horizontals.length).fill(null))\r\n        ];\r\n\r\n        this.parent = parent;\r\n        this.model = model;\r\n        this.board = board;\r\n        this.player = player;\r\n    }\r\n\r\n\r\n    public async run() {\r\n        //Si le jeu est fini on simule et on backpropage\r\n        if (this.board.isFinished()) {\r\n            const winner = this.board.getWinner();\r\n            if (winner === -1) return this.backpropagation(0); //Draw\r\n            return this.backpropagation(winner === this.board.tour ? 1 : -1);\r\n        }\r\n\r\n        //Si il n'y a pas de noeuds on simule et on backpropage et on ajoute les enfants\r\n        if (!this.expanded) {\r\n            this.expanded = true;\r\n            const [headValue, headPolicy] = await this.simulate();\r\n            this.backpropagation(headValue[0]);\r\n            this.expansion(headPolicy);\r\n        }\r\n        else {\r\n            await this.selection().run();\r\n        }\r\n    }\r\n\r\n    private selection():\r\n        MctsNodePipopipetteGo {\r\n        let bestMoveEnnemy: { bestNode: MctsNodePipopipetteGo | null, bestValue: number } = {\r\n            bestNode: null,\r\n            bestValue: -Infinity\r\n        };\r\n        let bestMove: { bestNode: MctsNodePipopipetteGo | null, bestValue: number } = {\r\n            bestNode: null,\r\n            bestValue: -Infinity\r\n        };\r\n\r\n        for (let _orientation = 0; _orientation < this.nodes.length; _orientation++) {\r\n            for (let _x = 0; _x < this.nodes[_orientation].length; _x++) {\r\n                for (let _y = 0; _y < this.nodes[_orientation][_x].length; _y++) {\r\n                    const node = this.nodes[_orientation][_x][_y]\r\n\r\n                    if (node) {\r\n                        const U = node.P * (Math.log(this.N + 1) / (1 + node.N))\r\n                        const value = node.Q + U;\r\n\r\n                        let playerCible = node.board.tour === this.player ? bestMove : bestMoveEnnemy;\r\n\r\n                        if (value > playerCible.bestValue) {\r\n                            playerCible.bestValue = value;\r\n                            playerCible.bestNode = node;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        if (!bestMoveEnnemy.bestNode && !bestMove.bestNode) {\r\n            throw new Error(\"No best node found\")\r\n        }\r\n\r\n        //There is no move for the ennemy\r\n        if (!bestMoveEnnemy.bestNode) return bestMove.bestNode!\r\n\r\n        //There is no move for the player\r\n        if (!bestMove.bestNode) return bestMoveEnnemy.bestNode\r\n\r\n        //If there is moves for both player we take the best move\r\n        if (bestMove.bestValue > -bestMoveEnnemy.bestValue) return bestMove.bestNode\r\n        return bestMoveEnnemy.bestNode\r\n\r\n    }\r\n\r\n    private async simulate() {\r\n        const input = tf.tensor([AlplhaZeroPlayer.createModelInput(this.board)]);\r\n        return Promise.all(\r\n            (this.model.apply(input) as [Tensor, Tensor]).map(t =>\r\n                t.data().then(data => (t.dispose(), data))\r\n            )\r\n        ).then(data => (input.dispose(), data));\r\n    }\r\n\r\n    private expansion(policyValues: Float32Array | Int32Array | Uint8Array) {\r\n        const numberOfMovesHorizontals = this.board.cells.length * (this.board.cells.length + 1);\r\n\r\n        //On enleve les coups deja joué\r\n        policyValues = policyValues.map((v, index) => {\r\n            const orientation = index < numberOfMovesHorizontals ? \"vertical\" : \"horizontal\";\r\n            const x = index < numberOfMovesHorizontals ? index % (this.board.cells.length + 1) : (index - numberOfMovesHorizontals) % this.board.cells.length;\r\n            const y = index < numberOfMovesHorizontals ? Math.floor(index / (this.board.cells.length + 1)) : Math.floor((index - numberOfMovesHorizontals) / this.board.cells.length);\r\n            if (orientation === \"vertical\" && this.board.verticals[y][x] !== -1) return 0;\r\n            if (orientation === \"horizontal\" && this.board.horizontals[y][x] !== -1) return 0;\r\n\r\n            return v;\r\n        })\r\n\r\n        const sum = Array.from(policyValues).reduce((a, b) => {\r\n            if (b === 0) return a;\r\n            return a + Math.E ** b\r\n        }, 0);\r\n\r\n\r\n        policyValues = policyValues.map(v => {\r\n            if (v === 0) return 0;\r\n            return Math.E ** v / sum;\r\n        });\r\n\r\n\r\n        for (let index = 0; index < policyValues.length; index++) {\r\n            if (policyValues[index] === 0) continue;\r\n            const orientation = index < numberOfMovesHorizontals ? \"vertical\" : \"horizontal\";\r\n            const x = index < numberOfMovesHorizontals ? index % (this.board.cells.length + 1) : (index - numberOfMovesHorizontals) % this.board.cells.length;\r\n            const y = index < numberOfMovesHorizontals ? Math.floor(index / (this.board.cells.length + 1)) : Math.floor((index - numberOfMovesHorizontals) / this.board.cells.length);\r\n\r\n            const child = new MctsNodePipopipetteGo(this.model, this.board.play(orientation, x, y)!, this.player, this);\r\n            child.P = policyValues[index];\r\n\r\n            this.nodes[orientation === \"vertical\" ? 0 : 1][x][y] = child;\r\n        }\r\n    }\r\n\r\n    private backpropagation(leafW: number) {\r\n        this.N++;\r\n        this.W += leafW;\r\n        this.Q = this.W / this.N;\r\n\r\n        if (this.parent) this.parent.backpropagation((this.parent.board.tour === this.board.tour ? 1 : -1) * leafW);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @returns \r\n     */\r\n    public getBestChild(stochastic: boolean = false): {\r\n        bestNode: MctsNodePipopipetteGo;\r\n        x: number;\r\n        y: number;\r\n        orientation: \"vertical\" | \"horizontal\";\r\n    } {\r\n        if (stochastic) {\r\n            let prob = Math.floor(Math.random() * this.N);\r\n            for (let _orientation = 0; _orientation < this.nodes.length; _orientation++) {\r\n                for (let _x = 0; _x < this.nodes[_orientation].length; _x++) {\r\n                    for (let _y = 0; _y < this.nodes[_orientation][_x].length; _y++) {\r\n                        const node = this.nodes[_orientation][_x][_y]\r\n                        if (node) {\r\n                            if (prob <= node.N) {\r\n                                return { bestNode: node, x: _x, y: _y, orientation: (_orientation === 0 ? \"vertical\" : \"horizontal\") }\r\n                            }\r\n                            prob -= node.N;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            throw new Error(\"No best node found\" + this.nodes.reduce((a, b) => a + b.reduce((a, b) => a + b.reduce((a, b) => a + (b ? b.N : 0), 0), 0), 0))\r\n        }\r\n        let bestNode: MctsNodePipopipetteGo | null = null;\r\n        let x: number = 0;\r\n        let y: number = 0;\r\n        let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n        let bestValue = -Infinity;\r\n\r\n        for (let _orientation = 0; _orientation < this.nodes.length; _orientation++) {\r\n            for (let _x = 0; _x < this.nodes[_orientation].length; _x++) {\r\n                for (let _y = 0; _y < this.nodes[_orientation][_x].length; _y++) {\r\n                    const node = this.nodes[_orientation][_x][_y]\r\n                    if (node) {\r\n                        //En mode deterministe on prend le meilleur coup\r\n                        const value = node.N\r\n                        if (value > bestValue) {\r\n                            orientation = (_orientation === 0 ? \"vertical\" : \"horizontal\");\r\n                            x = +_x;\r\n                            y = +_y;\r\n                            bestValue = value;\r\n                            bestNode = node;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return { bestNode: bestNode!, x, y, orientation };\r\n    }\r\n}","import { models } from \"../../models\";\r\nimport { Board } from \"../board\";\r\nimport { MctsNodePipopipetteGo } from \"../mctsAlphaZero\";\r\nimport { IaPlayer } from \"./IAPlayer\"\r\nimport * as tf from \"@tensorflow/tfjs\";\r\nimport \"@tensorflow/tfjs-backend-wasm\";\r\n\r\ntf.setBackend(\"wasm\");\r\n\r\n\r\nexport default class AlplhaZeroPlayer extends IaPlayer {\r\n    private model: tf.LayersModel | null = null;\r\n    private modelString: string;\r\n    private root: MctsNodePipopipetteGo | null = null\r\n    private mctsIteration: number\r\n\r\n    /**\r\n    * \r\n    * @param {number} minTimeToPlay - Le temps minimal pour jouer un coup.\r\n    */\r\n    constructor({ minTimeToPlay, model, mctsIteration, }: { minTimeToPlay?: number, model: string, mctsIteration: number }) {\r\n        super({ minTimeToPlay })\r\n        this.mctsIteration = mctsIteration\r\n        this.modelString = model\r\n    }\r\n\r\n    async playIa(board: Board, player: 0 | 1) {\r\n        if (!this.model) {\r\n            await tf.ready()\r\n            const { model, weights } = models.get(board.cells.length)!.get(this.modelString)!\r\n            this.model = await fetch((weights as any).default).then(async (res) => tf.loadLayersModel(tf.io.fromMemory({\r\n                weightData: base64ToArrayBuffer(await res.text()),\r\n                ...model\r\n            })))\r\n\r\n\r\n            if (!this.model) {\r\n                throw new Error(\"Model not loaded\")\r\n            }\r\n        }\r\n\r\n        this.root = new MctsNodePipopipetteGo(this.model, board, player)\r\n\r\n        for (let i = 0; i < this.mctsIteration; i++) {\r\n            await this.root.run()\r\n        }\r\n        console.log(this.root)\r\n        const { bestNode, ...coup } = this.root.getBestChild()\r\n        return coup\r\n    }\r\n\r\n    static createModelInput(board: Board) {\r\n        const historySize = 7\r\n        const size = board.cells.length + 1\r\n\r\n        const player1History: Pick<Board, \"horizontals\" | \"verticals\">[] = []\r\n        const player2History: Pick<Board, \"horizontals\" | \"verticals\">[] = []\r\n\r\n        let current: Board | null = board\r\n        while (current?.previousBoard) {\r\n            if (player1History.length === historySize && player2History.length === historySize) break\r\n            if (current.previousBoard.tour === 0 && player1History.length < historySize) {\r\n                player1History.push({\r\n                    verticals: [...current.verticals.map(v => v.map(v => v === 0 ? 1 : 0)), Array(size).fill(0)],\r\n                    horizontals: current.horizontals.map(h => [...h.map(h => h === 0 ? 1 : 0), 0]),\r\n                    // cells: [...current.cells.map(c => [...c.map(c => c === 0 ? 1 : 0), 0]), Array(size).fill(0)],\r\n                })\r\n            } else if (player2History.length < historySize) {\r\n                player2History.push({\r\n                    verticals: [...current.verticals.map(v => v.map(v => v === 1 ? 1 : 0)), Array(size).fill(0)],\r\n                    horizontals: current.horizontals.map(h => [...h.map(h => h === 1 ? 1 : 0), 0]),\r\n                    // cells: [...current.cells.map(c => [...c.map(c => c === 1 ? 1 : 0), 0]), Array(size).fill(0)],\r\n                })\r\n            }\r\n            current = current.previousBoard\r\n        }\r\n\r\n        if (player1History.length < historySize) {\r\n            player1History.push(...new Array(historySize - player1History.length).fill({\r\n                verticals: new Array(size).fill(new Array(size).fill(0)),\r\n                horizontals: new Array(size).fill(new Array(size).fill(0)),\r\n                // cells: new Array(size).fill(new Array(size).fill(0)),\r\n            }))\r\n        }\r\n\r\n        if (player2History.length < historySize) {\r\n            player2History.push(...new Array(historySize - player2History.length).fill({\r\n                verticals: new Array(size).fill(new Array(size).fill(0)),\r\n                horizontals: new Array(size).fill(new Array(size).fill(0)),\r\n                // cells: new Array(size).fill(new Array(size).fill(0)),\r\n            }))\r\n        }\r\n\r\n        return [\r\n            ...player1History.map(({ verticals }) => verticals),\r\n            ...player1History.map(({ horizontals }) => horizontals),\r\n            // ...player1History.map(({ cells }) => cells),\r\n            ...player2History.map(({ verticals }) => verticals),\r\n            ...player2History.map(({ horizontals }) => horizontals),\r\n            // ...player2History.map(({ cells }) => cells),\r\n            new Array(size).fill(Array(size).fill(board.tour ? 0 : 1))\r\n        ];\r\n    }\r\n}\r\n\r\nconst base64ToArrayBuffer = (base64String: string) => {\r\n    const binaryString = atob(base64String); // Décoder la chaîne Base64 en binaire\r\n    const len = binaryString.length;\r\n    const bytes = new Uint8Array(len); // Créer un tableau d'octets (ArrayBuffer)\r\n    for (let i = 0; i < len; i++) {\r\n        bytes[i] = binaryString.charCodeAt(i);\r\n    }\r\n    return bytes.buffer; // Retourner le buffer sous-jacent\r\n};","import { Board, Coup, PlayerValue } from \"../board\";\r\nimport { AlphaBetaPlayer } from \"./AlphaBetaPlayer\";\r\nimport { IaPlayer } from \"./IAPlayer\";\r\nimport { MctsPlayer } from \"./MCTSPlayer\";\r\nimport { MinimaxPlayer } from \"./MinimaxPlayer\";\r\n\r\n\r\n/**\r\n * Classe représentant un joueur IA qui est un sous ensemble des joueurs IA. Dans ce cas se sont \"minimax\", \"alphabeta\" et \"mcts\".\r\n * @extends IaPlayer\r\n */\r\nexport class FastestPlayer extends IaPlayer {\r\n\r\n    readonly parameters: ConstructorParameters<typeof MinimaxPlayer>[0] & ConstructorParameters<typeof AlphaBetaPlayer>[0] & ConstructorParameters<typeof MctsPlayer>[0]\r\n\r\n    /*\r\n     * Les IA à jouer.\r\n     */\r\n    readonly ias: (\"minimax\" | \"alphabeta\" | \"mcts\")[] = [\"minimax\", \"alphabeta\", \"mcts\"]\r\n\r\n    /**\r\n     * \r\n     * @param {number} depth - La profondeur de recherche.\r\n     */\r\n    constructor(parameters: ConstructorParameters<typeof MinimaxPlayer>[0] & ConstructorParameters<typeof AlphaBetaPlayer>[0] & ConstructorParameters<typeof MctsPlayer>[0]) {\r\n        super(parameters);\r\n        this.parameters = parameters;\r\n    }\r\n\r\n    /**\r\n     * Joue un coup sur le plateau.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    async playIa(board: Board, player: PlayerValue): Promise<Coup> {\r\n        const workers: Worker[] = []\r\n\r\n        const [coup, ia_1] = await Promise.race(this.ias.map(ia => {\r\n            return new Promise<[Coup, typeof ia]>((resolve) => {\r\n                const worker = new Worker(new URL(\"../playerWorker.ts\", import.meta.url));\r\n                workers.push(worker);\r\n                worker.postMessage({ board: JSON.parse(JSON.stringify(board)), parameters: this.parameters, player, type: ia });\r\n                worker.addEventListener(\"message\", (e) => {\r\n                    resolve([e.data, ia]);\r\n                });\r\n            });\r\n        }));\r\n        workers.forEach(w => w.terminate());\r\n        console.log(`Player ${player} (${ia_1})`)\r\n        return coup;\r\n    }\r\n}\r\n","import { Board, Coup, PlayerValue } from \"../board\"\r\nimport { Player } from \"./Player\"\r\n\r\n/**\r\n * Classe représentant un joueur humain.\r\n * @extends Player\r\n */\r\nexport class HumanPlayer extends Player {\r\n\r\n    /**\r\n     * Joue un coup sur le plateau.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    play(board: Board, player: PlayerValue): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            const start = performance.now()\r\n            this.addEventListener(\"play\", (e: Event) => {\r\n                const end = performance.now()\r\n                this.totalTime += end - start\r\n                this.totalMove++\r\n                this.times.push(end - start)\r\n                console.log(`Player ${player} (${this.constructor.name}) Time: ${end - start} Average time: ${this.totalTime / this.totalMove}ms`)\r\n                const customEvent = e as CustomEvent<Coup>;\r\n                resolve(customEvent.detail);\r\n            }, { once: true })\r\n        })\r\n    }\r\n}","import { Board } from \"./board\";\r\n\r\nexport class MctsNode {\r\n    public wins: number;\r\n    public visits: number;\r\n    public nodes: Map<\"vertical\" | \"horizontal\", Map<number, Map<number, MctsNode>>>;\r\n    public parent: MctsNode | null;\r\n    private board: Board;\r\n    private player: 0 | 1;\r\n    private simulation: number;\r\n    private c: number\r\n    private generator: Generator<{ orientation: \"vertical\" | \"horizontal\"; x: number; y: number, board: Board }, void, unknown>;\r\n\r\n    constructor(board: Board, player: 0 | 1, simulation: number, c: number, parent: MctsNode | null = null) {\r\n        this.wins = 0;\r\n        this.visits = 0;\r\n        this.nodes = new Map();\r\n        this.parent = parent;\r\n        this.generator = board.getNodes();\r\n        this.board = board;\r\n        this.simulation = simulation;\r\n        this.player = player;\r\n        this.c = c;\r\n    }\r\n\r\n\r\n    public run() {\r\n        if (this.board.isFinished()) {\r\n            for (let i = 0; i < this.simulation; i++) {\r\n                this.backpropagation(this.simulate());\r\n            }\r\n            return\r\n        }\r\n\r\n        let newChild = this.expansion()\r\n\r\n        if (newChild) {\r\n            for (let i = 0; i < this.simulation; i++) {\r\n                newChild.backpropagation(newChild.simulate());\r\n            }\r\n        }\r\n        else {\r\n            const { bestNode } = this.selection();\r\n            bestNode.run();\r\n        }\r\n    }\r\n\r\n    private selection(): {\r\n        bestNode: MctsNode;\r\n        x: number;\r\n        y: number;\r\n        orientation: \"vertical\" | \"horizontal\";\r\n    } {\r\n        let bestNode: MctsNode | null = null;\r\n        let x: number = 0;\r\n        let y: number = 0;\r\n        let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n        let bestValue = -Infinity;\r\n        this.nodes.forEach((row, _orientation) => {\r\n            row.forEach((cell, _x) => {\r\n                cell.forEach((node, _y) => {\r\n                    const value = node.wins / node.visits + this.c * Math.sqrt(2 * Math.log(this.visits) / node.visits);\r\n                    if (value > bestValue) {\r\n                        bestValue = value;\r\n                        orientation = _orientation as \"vertical\" | \"horizontal\";\r\n                        x = +_x;\r\n                        y = +_y;\r\n                        bestNode = node;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return { bestNode: bestNode!, x, y, orientation };\r\n    }\r\n\r\n    private simulate() {\r\n        let board = this.board;\r\n        while (true) {\r\n            const { value, done } = board.getNodes().next();\r\n            if (done) break;\r\n            board = value.board\r\n        }\r\n        return board.getWinner() === this.player;\r\n    }\r\n\r\n    private expansion() {\r\n        const { value, done } = this.generator.next();\r\n\r\n        if (done) return false;\r\n\r\n        const { orientation, x, y, board } = value;\r\n        const child = new MctsNode(board, this.player, this.simulation, this.c, this);\r\n        let mapOrientation = this.nodes.get(orientation);\r\n        if (!mapOrientation) {\r\n            mapOrientation = new Map();\r\n            this.nodes.set(orientation, mapOrientation);\r\n        }\r\n\r\n        let mapX = mapOrientation.get(x);\r\n        if (!mapX) {\r\n            mapX = new Map();\r\n            mapOrientation.set(x, mapX);\r\n        }\r\n\r\n        mapX.set(y, child);\r\n\r\n        return child;\r\n    }\r\n\r\n    private backpropagation(won: boolean) {\r\n        if (won) {\r\n            this.wins++;\r\n        }\r\n        this.visits++;\r\n        if (this.parent) {\r\n            this.parent.backpropagation(won);\r\n        }\r\n    }\r\n\r\n    public getBestChild() {\r\n        let bestNode: MctsNode | null = null;\r\n        let x: number = 0;\r\n        let y: number = 0;\r\n        let orientation: \"vertical\" | \"horizontal\" = \"vertical\";\r\n        let bestValue = -Infinity;\r\n        this.nodes.forEach((row, _orientation) => {\r\n            row.forEach((cell, _x) => {\r\n                cell.forEach((node, _y) => {\r\n                    const value = node.wins / node.visits;\r\n                    if (value > bestValue) {\r\n                        orientation = _orientation as \"vertical\" | \"horizontal\";\r\n                        x = +_x;\r\n                        y = +_y;\r\n                        bestValue = value;\r\n                        bestNode = node;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return { bestNode: bestNode!, x, y, orientation };\r\n    }\r\n\r\n    getNumberVisited() {\r\n        return this.visits;\r\n    }\r\n\r\n}","import { Board, Coup, PlayerValue } from \"../board\";\r\nimport { MctsNode } from \"../mcts\";\r\nimport { IaPlayer } from \"./IAPlayer\";\r\n\r\n/**\r\n * Classe représentant un joueur IA qui joue avec l'algorithme MCTS.\r\n * @extends IaPlayer\r\n */\r\nexport class MctsPlayer extends IaPlayer {\r\n\r\n    /**\r\n     * Le nombre d'itérations\r\n     */\r\n    private iteration: number;\r\n\r\n    /**\r\n     * Le nombre de simulations par itération.\r\n     */\r\n    private simulation: number;\r\n\r\n    /**\r\n     * La constante C pour l'exploration.\r\n     */\r\n    private c: number\r\n\r\n    /**\r\n     * Le dernier plateau joué.\r\n     */\r\n    private lastBoard: Board | null = null;\r\n\r\n    /**\r\n     * Le dernier noeud joué.\r\n     */\r\n    private lastNode: MctsNode | null = null;\r\n\r\n\r\n    /**\r\n     * \r\n     * @param {number} iteration - Le nombre d'itérations.\r\n     * @param {number} simulation - Le nombre de simulations par itération.\r\n     * @param {number} c - La constante C pour l'exploration.\r\n     * @param {number} minTimeToPlay - Le temps minimal pour jouer un coup.\r\n     */\r\n    constructor(parameters: { iteration: number, simulation: number, c?: number, minTimeToPlay?: number }) {\r\n        super(parameters);\r\n        this.iteration = parameters.iteration;\r\n        this.simulation = parameters.simulation;\r\n        this.c = parameters.c || Math.sqrt(2);\r\n    }\r\n\r\n\r\n    /**\r\n     * Joue un coup sur le plateau.\r\n     * \r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    playIa(board: Board, player: PlayerValue): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            let bestNode: MctsNode | null = null;\r\n            if (this.lastBoard && this.lastNode) {\r\n                const played = this.lastBoard\r\n                    .horizontals\r\n                    .flatMap((row, y) => row.map((cell, x) => cell === -1 && board.horizontals[y][x] !== -1 ? { x, y, orientation: \"horizontal\" } : null))\r\n                    .filter(x => x)\r\n                    .concat(\r\n                        this.lastBoard\r\n                            .verticals\r\n                            .flatMap((row, y) => row.map((cell, x) => cell === -1 && board.verticals[y][x] !== -1 ? { x, y, orientation: \"vertical\" } : null))\r\n                            .filter(x => x)\r\n                    ) as { x: number, y: number, orientation: \"vertical\" | \"horizontal\" }[]\r\n\r\n                if (played.length === 0) {\r\n                    bestNode = this.lastNode;\r\n                }\r\n\r\n\r\n                let bestValue = -Infinity;\r\n                if (played.length > 0) {\r\n                    for (const coup of permute(played)) {\r\n                        let currentNode: MctsNode | null = this.lastNode!.nodes.get(coup[0].orientation)?.get(coup[0].x)?.get(coup[0].y) || null;\r\n                        for (let i = 1; i < coup.length; i++) {\r\n                            currentNode = currentNode?.nodes.get(coup[i].orientation)?.get(coup[i].x)?.get(coup[i].y) || null;\r\n                            if (!currentNode) break;\r\n                        }\r\n                        if (currentNode) {\r\n                            if (currentNode.wins > bestValue) {\r\n                                bestValue = currentNode.wins;\r\n                                bestNode = currentNode;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            let root = bestNode || new MctsNode(board, player, this.simulation, this.c);\r\n            while (root.getNumberVisited() < this.iteration * this.simulation) {\r\n                root.run();\r\n            }\r\n            this.dispatchEvent(new CustomEvent(\"tree\", { detail: root }));\r\n            let bestChild = root.getBestChild();\r\n            this.lastNode = bestChild.bestNode;\r\n            this.lastBoard = board.play(bestChild.orientation, bestChild.x, bestChild.y);\r\n            resolve({ x: bestChild.x, y: bestChild.y, orientation: bestChild.orientation });\r\n        })\r\n    }\r\n}\r\n\r\n\r\nfunction permute<T>(arr: T[]): T[][] {\r\n    let results: T[][] = [];\r\n\r\n    function permuteRecursively(subArr: T[], memo: T[]) {\r\n        if (subArr.length === 0) {\r\n            results.push(memo.slice());\r\n        } else {\r\n            for (let i = 0; i < subArr.length; i++) {\r\n                let curr = subArr.slice();\r\n                let next = curr.splice(i, 1);\r\n                permuteRecursively(curr, memo.concat(next));\r\n            }\r\n        }\r\n    }\r\n\r\n    permuteRecursively(arr, []);\r\n    return results;\r\n}","import { Board, Coup } from \"../board\";\r\nimport negamax from \"../negamax\";\r\nimport { IaPlayer } from \"./IAPlayer\";\r\n\r\nexport class MinimaxPlayer extends IaPlayer {\r\n    private depth: number;\r\n\r\n    private depthLimit?: number;\r\n\r\n    constructor(paramters: { depth: number, minTimeToPlay?: number, depthLimit?: number }) {\r\n        super(paramters);\r\n        this.depth = paramters.depth;\r\n        this.depthLimit = paramters.depthLimit;\r\n    }\r\n\r\n    playIa(board: Board, player: 0 | 1): Promise<Coup> {\r\n        return new Promise<Coup>((resolve) => {\r\n            const { nodes, ...coup } = negamax(board, this.depth, player, this.depthLimit)\r\n            console.log(`Player ${player} (${(this as any).constructor.name}) : ${nodes} nodes`)\r\n            resolve(coup);\r\n        })\r\n    }\r\n}","import { Board, Coup, PlayerValue } from \"./board\";\r\n\r\nexport default function negamax(board: Board, _depth: number, idPlayer: PlayerValue, depthLimit?: number): Coup & {\r\n  nodes: number;\r\n  value: number;\r\n} {\r\n  let coup: Coup = { x: 0, y: 0, orientation: \"horizontal\" };\r\n  let nodes = 0;\r\n\r\n  //key is horizontals stringified + verticals stringified + score stringified + nextPlayer stringified\r\n  //value is the evaluation\r\n  const history = new Map<string, number>();\r\n\r\n  function generateKey(board: Board): string {\r\n    return `${board.horizontals.map(h => h.map(e => e !== -1 ? 1 : 0).join(\"\")).join(\"\")}${board.verticals.map(h => h.map(e => e !== -1 ? 1 : 0).join(\"\")).join(\"\")}${board.score.join(\"\")}${board.tour}`;\r\n  }\r\n\r\n  function _negamax(board: Board, depth: number, maximizingPlayer: boolean): number {\r\n    if (depth === 0 || board.isFinished())\r\n      return board.evaluation(idPlayer) * (maximizingPlayer ? 1 : -1)\r\n\r\n    let value = -Infinity;\r\n\r\n    for (const { board: node, ...coupPlayed } of board.getNodes(depthLimit)) {\r\n      nodes++;\r\n      const key = generateKey(node);\r\n\r\n      if (history.has(key)) {\r\n        value = Math.max(value, history.get(generateKey(node))!);\r\n        continue;\r\n      }\r\n\r\n      const result = _negamax(node, depth - 1, !maximizingPlayer);\r\n\r\n      history.set(key, -result);\r\n\r\n      if (-result > value) {\r\n        if (depth === _depth) coup = coupPlayed\r\n        value = -result;\r\n      }\r\n    }\r\n    return value;\r\n  }\r\n\r\n  const value = _negamax(board, _depth, true)\r\n\r\n  return {\r\n    ...coup,\r\n    value,\r\n    nodes\r\n  };\r\n}","import { Board, Coup, PlayerValue } from \"../board\";\r\nimport { IaPlayer } from \"./IAPlayer\";\r\n\r\n/**\r\n * Classe représentant un joueur IA qui joue de manière aléatoire.\r\n * @extends IaPlayer\r\n */\r\nexport class RandomPlayer extends IaPlayer {\r\n    /**\r\n     * Joue un coup aléatoire sur le plateau.\r\n     * @param {Board} board - Le plateau de jeu actuel.\r\n     * @param {PlayerValue} player - La valeur du joueur actuel.\r\n     * @returns {Promise<Coup>} - Une promesse qui se résout avec le coup joué.\r\n     */\r\n    playIa(board: Board, player: PlayerValue): Promise<Coup> {\r\n        return Promise.resolve(board.getNodes().next().value!)\r\n    }\r\n}\r\n","import { MainToWorkerEventMap } from \"./@types/worker\";\r\nimport { PlayerValue, PlayValue } from \"./utils/board\";\r\nimport Game from \"./utils/game\";\r\nimport { AlphaBetaPlayer } from \"./utils/players/AlphaBetaPlayer\";\r\nimport AlplhaZeroPlayer from \"./utils/players/AlphaZeroPlayer\";\r\nimport { FastestPlayer } from \"./utils/players/FastestPlayer\";\r\nimport { HumanPlayer } from \"./utils/players/HumanPlayer\";\r\nimport { MctsPlayer } from \"./utils/players/MCTSPlayer\";\r\nimport { MinimaxPlayer } from \"./utils/players/MinimaxPlayer\";\r\nimport { RandomPlayer } from \"./utils/players/RandomPlayer\";\r\n\r\ndeclare var self: DedicatedWorkerGlobalScope;\r\n\r\nDedicatedWorkerGlobalScope.prototype.emit = function (...data) {\r\n    this.postMessage({ type: data[0], data: data[1] });\r\n}\r\n\r\nself.addEventListener(\"message\", ({ data: { data, type } }) => {\r\n    self.dispatchEvent(new CustomEvent(type, {\r\n        detail: data\r\n    }));\r\n});\r\n\r\nlet game: Game | null = null;\r\n\r\nself.addEventListener(\"start\", ({ detail: { player1, player2, size } }) => {\r\n    if (game) return;\r\n\r\n    const player1Instance = createPlayer(player1);\r\n    const player2Instance = createPlayer(player2);\r\n\r\n    game = new Game(size, player1Instance, player2Instance);\r\n\r\n    if (player1Instance instanceof HumanPlayer) {\r\n        self.addEventListener(\"play\", (e) => {\r\n            player1Instance.dispatchEvent(new CustomEvent(\"play\", {\r\n                detail: e.detail\r\n            }));\r\n        });\r\n    }\r\n\r\n    if (player2Instance instanceof HumanPlayer) {\r\n        self.addEventListener(\"play\", (e) => {\r\n            player2Instance.dispatchEvent(new CustomEvent(\"play\", {\r\n                detail: e.detail\r\n            }));\r\n        });\r\n    }\r\n\r\n    self.emit(\"change\", game.getBoard());\r\n\r\n    game.addEventListener(\"end\", (e) => {\r\n        const { winner } = (\r\n            e as CustomEvent<{\r\n                winner: PlayerValue\r\n            }>\r\n        ).detail;\r\n        self.emit(\"end\", {\r\n            winner\r\n        });\r\n    });\r\n\r\n    game.addEventListener(\"played\", (e) => {\r\n        const { board } = (\r\n            e as CustomEvent<{\r\n                played: {\r\n                    x: number;\r\n                    y: number;\r\n                    orientation: string;\r\n                    player: PlayerValue;\r\n                };\r\n                board: {\r\n                    verticals: ReadonlyArray<ReadonlyArray<PlayValue>>;\r\n                    horizontals: ReadonlyArray<ReadonlyArray<PlayValue>>;\r\n                    cells: ReadonlyArray<ReadonlyArray<PlayValue>>;\r\n                    score: readonly [number, number];\r\n                    tour: PlayerValue;\r\n                };\r\n            }>\r\n        ).detail;\r\n\r\n        self.emit(\"change\", board);\r\n    });\r\n\r\n    game.start().then(() => {\r\n        self.emit(\"end\", {\r\n            winner: game!.getBoard().getWinner()\r\n        });\r\n    });\r\n});\r\n\r\n\r\nfunction createPlayer(player: MainToWorkerEventMap[\"start\"][\"detail\"][\"player1\"]) {\r\n    switch (player.type) {\r\n        case \"human\":\r\n            return new HumanPlayer();\r\n        case \"random\":\r\n            return new RandomPlayer(player);\r\n        case \"minimax\":\r\n            return new MinimaxPlayer(player);\r\n        case \"alphabeta\":\r\n            return new AlphaBetaPlayer(player);\r\n        case \"mcts\":\r\n            return new MctsPlayer(player);\r\n        case \"fastest\":\r\n            return new FastestPlayer(player);\r\n        case \"alphaZero\":\r\n            return new AlplhaZeroPlayer(player);\r\n    }\r\n}\r\n\r\n\r\nexport { };\r\n\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [99], () => (__webpack_require__(420)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.amdD = function () {\n\tthrow new Error('define cannot be used indirect');\n};","__webpack_require__.amdO = {};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"99\":\"60a619ee\",\"843\":\"9637cd86\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/POLYTECH-IA-PROJET-PIPOPIPETTE/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t661: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkpolytech_projet_ia_pipopipette\"] = self[\"webpackChunkpolytech_projet_ia_pipopipette\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(99).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["Board","constructor","BoardOrSize","cells","verticals","horizontals","previousBoard","score","tour","this","Array","fill","map","getWinner","play","orientation","x","y","newHorizontals","row","newVerticals","newCells","newScore","newTour","console","error","result","check","push","length","forEach","cell","isFinished","_horizontals","evaluation","idPlayer","getNodes","depthLimit","playable","flatMap","value","filter","_ref","currentIndex","randomIndex","Math","floor","random","i","board","undefined","node","Game","EventTarget","size","player1","player2","super","players","playing","getBoard","then","coup","newBoard","dispatchEvent","CustomEvent","detail","played","player","winner","start","Player","arguments","totalTime","totalMove","times","IaPlayer","minTimeToPlay","Promise","all","async","performance","now","playIa","end","log","name","resolve","setTimeout","AlphaBetaPlayer","paramters","depth","nodes","_depth","history","Map","generateKey","h","e","join","_nigamax","maximizingPlayer","alpha","beta","Infinity","coupPlayed","key","has","max","get","set","nigamax","models","model","model_3x3_16_5_1","weights","weights_3x3_16_5_1","model_3x3_16_5_2","weights_3x3_16_5_2","model_3x3_16_5_3","weights_3x3_16_5_3","MctsNodePipopipetteGo","parent","N","W","Q","P","expanded","from","run","backpropagation","selection","headValue","headPolicy","simulate","expansion","bestMoveEnnemy","bestNode","bestValue","bestMove","_orientation","_x","_y","U","playerCible","Error","input","tf","AlplhaZeroPlayer","createModelInput","apply","t","data","dispose","policyValues","numberOfMovesHorizontals","v","index","sum","reduce","a","b","E","child","leafW","getBestChild","prob","mctsIteration","modelString","root","fetch","default","weightData","base64ToArrayBuffer","res","text","player1History","player2History","current","_current","_ref2","_ref3","_ref4","_ref5","base64String","binaryString","atob","len","bytes","Uint8Array","charCodeAt","buffer","FastestPlayer","parameters","ias","workers","ia_1","race","ia","worker","Worker","URL","postMessage","JSON","parse","stringify","type","addEventListener","w","terminate","HumanPlayer","once","MctsNode","simulation","c","wins","visits","generator","newChild","sqrt","done","next","mapOrientation","mapX","won","getNumberVisited","MctsPlayer","iteration","lastBoard","lastNode","concat","arr","results","permuteRecursively","subArr","memo","slice","curr","splice","permute","_nodes$get","_nodes$get$get","currentNode","_currentNode","_currentNode$nodes$ge","_currentNode$nodes$ge2","bestChild","MinimaxPlayer","_negamax","negamax","RandomPlayer","DedicatedWorkerGlobalScope","prototype","emit","self","game","createPlayer","player1Instance","player2Instance","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","amdD","amdO","deferred","chunkIds","fn","priority","notFulfilled","fulfilled","j","Object","keys","every","r","n","getter","__esModule","d","leafPrototypes","getProto","getPrototypeOf","obj","mode","ns","create","def","indexOf","getOwnPropertyNames","definition","o","defineProperty","enumerable","f","chunkId","promises","u","miniCssF","g","globalThis","Function","window","prop","hasOwnProperty","Symbol","toStringTag","nmd","paths","children","p","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop"],"sourceRoot":""}